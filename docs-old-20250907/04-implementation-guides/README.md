# Implementation Guides

Step-by-step implementation guides for MediaNest features and components.

## Overview

This section provides detailed implementation guides for building and extending MediaNest functionality. Each guide includes code examples, best practices, and common pitfalls to avoid.

## Core Implementation Guides

### Authentication & Security

- [Authentication Implementation](./authentication.md) - Implementing Plex OAuth and JWT auth
- [Security Implementation](./security.md) - Security best practices and implementation
- [CSRF Protection](./csrf-protection.md) - Cross-site request forgery protection
- [Rate Limiting](./rate-limiting.md) - API rate limiting implementation

### API Development

- [REST API Implementation](./api-implementation.md) - Building REST endpoints
- [Error Handling](./error-handling.md) - Comprehensive error handling strategy
- [Input Validation](./input-validation.md) - Request validation with Zod
- [Response Standards](./response-standards.md) - Consistent response formatting

### Frontend Development

- [React Component Development](./react-components.md) - Building reusable components
- [State Management](./state-management.md) - Managing application state
- [API Client Implementation](./api-client.md) - Frontend API integration
- [Testing React Components](./testing-components.md) - Component testing strategies

### Data & Integration

- [Database Implementation](./database.md) - Database design and queries
- [Plex Integration](./plex-integration.md) - Integrating with Plex Media Server
- [Search Implementation](./search.md) - Full-text search functionality
- [File Upload Handling](./file-uploads.md) - Secure file upload implementation

## Getting Started

### Prerequisites

Before implementing any features, ensure you have:

1. **Development Environment** set up according to [Getting Started](../01-getting-started/README.md)
2. **Architecture Understanding** from [Architecture Docs](../02-architecture/README.md)
3. **API Reference** knowledge from [API Docs](../03-api-reference/README.md)
4. **Testing Strategy** understanding from [Testing Docs](../05-testing/README.md)

### Implementation Process

1. **Plan** - Review architecture and API design
2. **Implement** - Follow the specific implementation guide
3. **Test** - Write comprehensive tests
4. **Review** - Code review and quality checks
5. **Document** - Update relevant documentation

## Code Standards

### TypeScript Configuration

`json\n{\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"noImplicitReturns\": true,\n    \"noFallthroughCasesInSwitch\": true,\n    \"noUncheckedIndexedAccess\": true,\n    \"exactOptionalPropertyTypes\": true\n  }\n}\n`\n\n### ESLint Configuration\n\n`javascript\nmodule.exports = {\n  extends: [\n    '@typescript-eslint/recommended',\n    '@typescript-eslint/recommended-requiring-type-checking',\n    'prettier'\n  ],\n  rules: {\n    '@typescript-eslint/no-unused-vars': 'error',\n    '@typescript-eslint/explicit-function-return-type': 'warn',\n    '@typescript-eslint/no-explicit-any': 'error'\n  }\n};\n`\n\n### Prettier Configuration\n\n`json\n{\n  \"semi\": true,\n  \"trailingComma\": \"es5\",\n  \"singleQuote\": true,\n  \"printWidth\": 100,\n  \"tabWidth\": 2\n}\n`\n\n## Common Patterns\n\n### Service Layer Pattern\n\n`typescript\n// services/user.service.ts\nexport class UserService {\n  constructor(\n    private userRepository: UserRepository,\n    private encryptionService: EncryptionService\n  ) {}\n  \n  async createUser(userData: CreateUserData): Promise<User> {\n    // Validate input\n    const validatedData = CreateUserSchema.parse(userData);\n    \n    // Business logic\n    const hashedPassword = await this.encryptionService.hashPassword(\n      validatedData.password\n    );\n    \n    // Repository call\n    return this.userRepository.create({\n      ...validatedData,\n      password: hashedPassword\n    });\n  }\n}\n`\n\n### Repository Pattern\n\n`typescript\n// repositories/user.repository.ts\nexport class UserRepository {\n  constructor(private prisma: PrismaClient) {}\n  \n  async create(data: CreateUserData): Promise<User> {\n    return this.prisma.user.create({\n      data,\n      select: this.getUserSelect() // Don't return password\n    });\n  }\n  \n  async findByEmail(email: string): Promise<User | null> {\n    return this.prisma.user.findUnique({\n      where: { email },\n      select: this.getUserSelect()\n    });\n  }\n  \n  private getUserSelect() {\n    return {\n      id: true,\n      email: true,\n      username: true,\n      role: true,\n      createdAt: true,\n      // password: false (excluded for security)\n    };\n  }\n}\n`\n\n### Controller Pattern\n\n`typescript\n// controllers/user.controller.ts\nexport class UserController {\n  constructor(private userService: UserService) {}\n  \n  @asyncHandler\n  async createUser(req: Request, res: Response): Promise<void> {\n    // Input validation happens in middleware\n    const userData = req.body as CreateUserData;\n    \n    // Service call\n    const user = await this.userService.createUser(userData);\n    \n    // Standard response\n    res.status(201).json({\n      success: true,\n      data: { user }\n    });\n  }\n}\n`\n\n### Error Handling Pattern\n\n`typescript\n// utils/error-handler.ts\nexport class AppError extends Error {\n  constructor(\n    public code: string,\n    message: string,\n    public statusCode: number = 500,\n    public details?: any\n  ) {\n    super(message);\n    this.name = 'AppError';\n  }\n}\n\n// Async handler wrapper\nexport const asyncHandler = (fn: Function) => {\n  return (req: Request, res: Response, next: NextFunction) => {\n    Promise.resolve(fn(req, res, next)).catch(next);\n  };\n};\n`\n\n## Database Patterns\n\n### Migration Example\n\n`sql\n-- migrations/001_create_users_table.sql\nCREATE TABLE users (\n    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n    email VARCHAR(255) UNIQUE NOT NULL,\n    username VARCHAR(100) UNIQUE NOT NULL,\n    password_hash VARCHAR(255) NOT NULL,\n    role user_role NOT NULL DEFAULT 'user',\n    plex_id VARCHAR(100) UNIQUE,\n    created_at TIMESTAMPTZ DEFAULT NOW(),\n    updated_at TIMESTAMPTZ DEFAULT NOW()\n);\n\nCREATE INDEX idx_users_email ON users(email);\nCREATE INDEX idx_users_plex_id ON users(plex_id);\n`\n\n### Repository Query Patterns\n\n`typescript\n// Complex query example\nasync findUsersWithMediaStats(filters: UserFilters): Promise<UserWithStats[]> {\n  const where: Prisma.UserWhereInput = {\n    role: filters.role,\n    createdAt: filters.dateRange ? {\n      gte: filters.dateRange.start,\n      lte: filters.dateRange.end\n    } : undefined\n  };\n  \n  return this.prisma.user.findMany({\n    where,\n    include: {\n      _count: {\n        select: {\n          mediaRequests: true,\n          favorites: true\n        }\n      }\n    },\n    orderBy: { createdAt: 'desc' },\n    take: filters.limit || 20,\n    skip: (filters.page - 1) * (filters.limit || 20)\n  });\n}\n`\n\n## Frontend Patterns\n\n### Custom Hook Pattern\n\n`typescript\n// hooks/useAuth.ts\nexport function useAuth() {\n  const [user, setUser] = useState<User | null>(null);\n  const [loading, setLoading] = useState(true);\n  \n  useEffect(() => {\n    checkAuthStatus();\n  }, []);\n  \n  const checkAuthStatus = async () => {\n    try {\n      const response = await api.auth.me();\n      setUser(response.data.user);\n    } catch (error) {\n      setUser(null);\n    } finally {\n      setLoading(false);\n    }\n  };\n  \n  const login = async (credentials: LoginCredentials) => {\n    const response = await api.auth.login(credentials);\n    setUser(response.data.user);\n    return response;\n  };\n  \n  const logout = async () => {\n    await api.auth.logout();\n    setUser(null);\n  };\n  \n  return {\n    user,\n    loading,\n    isAuthenticated: !!user,\n    isAdmin: user?.role === 'admin',\n    login,\n    logout,\n    refetch: checkAuthStatus\n  };\n}\n`\n\n### Component Pattern\n\n`typescript\n// components/MediaCard.tsx\ninterface MediaCardProps {\n  media: MediaItem;\n  onRequest?: (mediaId: string) => void;\n  showActions?: boolean;\n}\n\nexport function MediaCard({ \n  media, \n  onRequest, \n  showActions = true \n}: MediaCardProps) {\n  const { user } = useAuth();\n  const [isRequesting, setIsRequesting] = useState(false);\n  \n  const handleRequest = async () => {\n    if (!onRequest) return;\n    \n    setIsRequesting(true);\n    try {\n      await onRequest(media.id);\n    } finally {\n      setIsRequesting(false);\n    }\n  };\n  \n  return (\n    <Card className=\"media-card\">\n      <CardMedia\n        component=\"img\"\n        image={media.posterUrl}\n        alt={media.title}\n      />\n      <CardContent>\n        <Typography variant=\"h6\">{media.title}</Typography>\n        <Typography variant=\"body2\" color=\"textSecondary\">\n          {media.year} â€¢ {media.rating}/10\n        </Typography>\n      </CardContent>\n      {showActions && user && (\n        <CardActions>\n          <Button\n            size=\"small\"\n            onClick={handleRequest}\n            disabled={isRequesting}\n            startIcon={isRequesting ? <CircularProgress size={16} /> : null}\n          >\n            {isRequesting ? 'Requesting...' : 'Request'}\n          </Button>\n        </CardActions>\n      )}\n    </Card>\n  );\n}\n`\n\n## Testing Patterns\n\n### Unit Test Pattern\n\n`typescript\n// __tests__/services/user.service.test.ts\ndescribe('UserService', () => {\n  let userService: UserService;\n  let mockUserRepository: jest.Mocked<UserRepository>;\n  let mockEncryptionService: jest.Mocked<EncryptionService>;\n  \n  beforeEach(() => {\n    mockUserRepository = {\n      create: jest.fn(),\n      findByEmail: jest.fn()\n    } as any;\n    \n    mockEncryptionService = {\n      hashPassword: jest.fn()\n    } as any;\n    \n    userService = new UserService(mockUserRepository, mockEncryptionService);\n  });\n  \n  describe('createUser', () => {\n    it('should create user with hashed password', async () => {\n      // Arrange\n      const userData = {\n        email: 'test@example.com',\n        username: 'testuser',\n        password: 'password123'\n      };\n      \n      mockEncryptionService.hashPassword.mockResolvedValue('hashed-password');\n      mockUserRepository.create.mockResolvedValue({\n        id: '1',\n        email: userData.email,\n        username: userData.username,\n        role: 'user'\n      } as User);\n      \n      // Act\n      const result = await userService.createUser(userData);\n      \n      // Assert\n      expect(mockEncryptionService.hashPassword).toHaveBeenCalledWith('password123');\n      expect(mockUserRepository.create).toHaveBeenCalledWith({\n        ...userData,\n        password: 'hashed-password'\n      });\n      expect(result.email).toBe(userData.email);\n    });\n  });\n});\n`\n\n## Security Considerations\n\n### Input Sanitization\n\n`typescript\n// middleware/sanitization.ts\nexport function sanitizeInput(req: Request, res: Response, next: NextFunction) {\n  // Sanitize string inputs\n  const sanitizeObject = (obj: any): any => {\n    if (typeof obj === 'string') {\n      return validator.escape(obj.trim());\n    }\n    if (Array.isArray(obj)) {\n      return obj.map(sanitizeObject);\n    }\n    if (obj && typeof obj === 'object') {\n      const sanitized: any = {};\n      for (const [key, value] of Object.entries(obj)) {\n        sanitized[key] = sanitizeObject(value);\n      }\n      return sanitized;\n    }\n    return obj;\n  };\n  \n  req.body = sanitizeObject(req.body);\n  req.query = sanitizeObject(req.query);\n  \n  next();\n}\n`\n\n### SQL Injection Prevention\n\n`` typescript\n// Always use parameterized queries with Prisma\nconst users = await prisma.user.findMany({\n  where: {\n    email: {\n      contains: searchTerm, // Prisma handles escaping\n      mode: 'insensitive'\n    }\n  }\n});\n\n// For raw queries, always use parameters\nconst result = await prisma.$queryRaw`\n  SELECT * FROM users \n  WHERE email = ${email} \n  AND role = ${role}\n`;\n ``\n\n## Performance Optimization\n\n### Database Optimization\n\n`typescript\n// Use select to limit returned fields\nconst users = await prisma.user.findMany({\n  select: {\n    id: true,\n    email: true,\n    username: true\n    // Don't select large fields unless needed\n  }\n});\n\n// Use pagination for large datasets\nconst paginatedUsers = await prisma.user.findMany({\n  skip: (page - 1) * limit,\n  take: limit,\n  orderBy: { createdAt: 'desc' }\n});\n\n// Use database-level aggregation\nconst userStats = await prisma.user.aggregate({\n  _count: true,\n  where: { role: 'user' }\n});\n`\n\n### Caching Strategy\n\n`` typescript\n// Cache frequently accessed data\nexport class UserService {\n  private cache = new Map<string, { data: any; expires: number }>();\n  \n  async getUser(id: string): Promise<User> {\n    const cacheKey = `user:${id}`;\n    const cached = this.cache.get(cacheKey);\n    \n    if (cached && cached.expires > Date.now()) {\n      return cached.data;\n    }\n    \n    const user = await this.userRepository.findById(id);\n    \n    // Cache for 5 minutes\n    this.cache.set(cacheKey, {\n      data: user,\n      expires: Date.now() + 5 * 60 * 1000\n    });\n    \n    return user;\n  }\n}\n ``\n\n## Deployment Considerations\n\n### Environment Configuration\n\n`` typescript\n// config/environment.ts\nconst requiredEnvVars = [\n  'DATABASE_URL',\n  'REDIS_URL', \n  'JWT_SECRET',\n  'PLEX_CLIENT_ID'\n] as const;\n\ntype RequiredEnvVar = typeof requiredEnvVars[number];\n\nfunction getEnvVar(name: RequiredEnvVar): string {\n  const value = process.env[name];\n  if (!value) {\n    throw new Error(`Required environment variable ${name} is not set`);\n  }\n  return value;\n}\n\nexport const config = {\n  database: {\n    url: getEnvVar('DATABASE_URL')\n  },\n  redis: {\n    url: getEnvVar('REDIS_URL')\n  },\n  jwt: {\n    secret: getEnvVar('JWT_SECRET'),\n    expiresIn: process.env.JWT_EXPIRES_IN || '30d'\n  },\n  plex: {\n    clientId: getEnvVar('PLEX_CLIENT_ID')\n  }\n};\n ``\n\n## Related Documentation\n\n- [Architecture Guide](../02-architecture/README.md) - System architecture overview\n- [API Reference](../03-api-reference/README.md) - Complete API documentation\n- [Testing Guide](../05-testing/README.md) - Testing strategies and examples\n- [Deployment Guide](../06-deployment/README.md) - Production deployment\n- [Security Guide](../07-security/README.md) - Security best practices
