/**
 * JWT Security Vulnerability Test Suite
 *
 * This test suite validates JWT implementation against OWASP security standards
 * and common JWT vulnerabilities including algorithm confusion, token forgery,
 * and timing attacks.
 */

import jwt from 'jsonwebtoken';
import crypto from 'crypto';
import { performance } from 'perf_hooks';

// Import JWT implementation
import { jwtFacade, JWTPayload } from '../backend/src/auth/jwt-facade';
import { verifyToken, generateToken, generateRefreshToken } from '../backend/src/utils/jwt';

interface SecurityTestResult {
  testName: string;
  status: 'PASS' | 'FAIL' | 'WARNING';
  severity: 'CRITICAL' | 'HIGH' | 'MEDIUM' | 'LOW';
  description: string;
  evidence?: any;
  recommendation?: string;
}

export class JWTSecurityValidator {
  private results: SecurityTestResult[] = [];

  constructor() {
    console.log('üîí JWT Security Validator initialized');
  }

  /**
   * Run complete JWT security validation suite
   */
  async runSecurityValidation(): Promise<SecurityTestResult[]> {
    console.log('üöÄ Starting JWT Security Validation...\n');

    // Algorithm confusion attacks
    await this.testAlgorithmConfusion();

    // None algorithm exploitation
    await this.testNoneAlgorithmBypass();

    // Signature validation bypasses
    await this.testSignatureBypass();

    // Token forgery attempts
    await this.testTokenForgery();

    // Key confusion attacks
    await this.testKeyConfusion();

    // Timing attack vulnerabilities
    await this.testTimingAttacks();

    // Token expiration handling
    await this.testExpirationHandling();

    // Refresh token security
    await this.testRefreshTokenSecurity();

    // Session management security
    await this.testSessionManagement();

    // Token storage and transmission
    await this.testTokenStorageTransmission();

    return this.results;
  }

  /**
   * Test Algorithm Confusion Attacks (CVE-2016-5431)
   * Tests RS256/HS256 confusion where RSA public key is used as HMAC secret
   */
  private async testAlgorithmConfusion(): Promise<void> {
    console.log('üîç Testing Algorithm Confusion Attacks...');

    try {
      // Test 1: RS256 to HS256 confusion
      const rsaPublicKey = `-----BEGIN PUBLIC KEY-----
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA4f5wg5l2hKsTeNem/V41
fGnJm6gOdrj8ym3rFkEjWT2btf0hl3UxXMfvZGpfKO4bkB7r7T6hXVTmdF3xJmrK
X8LmLAoOiQVvSqWs3DFvEXBQ+K8HhbHwLm0z2SKSZ7k1PAgr8ZhEm8y+lONJHf1m
2MZ7c5H6yFKCQlmqWNn0aDtQfR7kRJGW4dO5iTHUhDpbwqhRPTdsBQhL7n9ZE8Ij
GNrLJp9P1Q+Gzk3T4LzhPu5J5L1EJ7Z7yh3wBsHN5wX8yZa2pzQ4UsMr9hUvn6zN
q6L3o2Rm4J8eK9E8e1HLLkF8MNXgP6KQMZL5F7KgRy6zQiJ6W7K/EzSQQQ/QqwTE
WQIDAQAB
-----END PUBLIC KEY-----`;

      // Create malicious token using RSA public key as HMAC secret
      const maliciousPayload = { userId: 'attacker', role: 'admin' };

      try {
        const maliciousToken = jwt.sign(maliciousPayload, rsaPublicKey, { algorithm: 'HS256' });

        // Try to verify with vulnerable implementation
        const decoded = verifyToken(maliciousToken);

        this.addResult({
          testName: 'Algorithm Confusion (RS256->HS256)',
          status: 'FAIL',
          severity: 'CRITICAL',
          description: 'JWT implementation vulnerable to algorithm confusion attack',
          evidence: { maliciousToken, decoded },
          recommendation:
            'Enforce specific algorithm validation and never allow algorithm switching',
        });
      } catch (error) {
        this.addResult({
          testName: 'Algorithm Confusion (RS256->HS256)',
          status: 'PASS',
          severity: 'HIGH',
          description: 'Algorithm confusion attack properly rejected',
          evidence: { error: error.message },
        });
      }

      // Test 2: Algorithm header manipulation
      const validToken = generateToken({
        userId: 'user123',
        email: 'test@example.com',
        role: 'user',
      });

      const [header, payload, signature] = validToken.split('.');
      const decodedHeader = JSON.parse(Buffer.from(header, 'base64url').toString());

      // Modify algorithm to 'none'
      const modifiedHeader = Buffer.from(
        JSON.stringify({ ...decodedHeader, alg: 'none' }),
      ).toString('base64url');

      const modifiedToken = `${modifiedHeader}.${payload}.`;

      try {
        const decoded = verifyToken(modifiedToken);

        this.addResult({
          testName: 'Algorithm Header Manipulation',
          status: 'FAIL',
          severity: 'CRITICAL',
          description: 'JWT implementation allows algorithm header manipulation',
          evidence: { originalToken: validToken, modifiedToken, decoded },
          recommendation:
            'Implement strict algorithm validation and reject tokens with modified algorithms',
        });
      } catch (error) {
        this.addResult({
          testName: 'Algorithm Header Manipulation',
          status: 'PASS',
          severity: 'HIGH',
          description: 'Algorithm header manipulation properly rejected',
          evidence: { error: error.message },
        });
      }
    } catch (error) {
      this.addResult({
        testName: 'Algorithm Confusion Test Suite',
        status: 'WARNING',
        severity: 'MEDIUM',
        description: 'Algorithm confusion tests could not be completed',
        evidence: { error: error.message },
      });
    }
  }

  /**
   * Test None Algorithm Exploitation
   * Tests if JWT implementation accepts tokens with 'none' algorithm
   */
  private async testNoneAlgorithmBypass(): Promise<void> {
    console.log('üîç Testing None Algorithm Bypass...');

    try {
      // Create token with 'none' algorithm
      const noneAlgPayload = {
        userId: 'attacker',
        email: 'attacker@evil.com',
        role: 'admin',
        exp: Math.floor(Date.now() / 1000) + 3600,
      };

      const noneAlgHeader = { alg: 'none', typ: 'JWT' };

      const header = Buffer.from(JSON.stringify(noneAlgHeader)).toString('base64url');
      const payload = Buffer.from(JSON.stringify(noneAlgPayload)).toString('base64url');

      // Create token without signature (none algorithm)
      const noneAlgToken = `${header}.${payload}.`;

      try {
        const decoded = verifyToken(noneAlgToken);

        this.addResult({
          testName: 'None Algorithm Bypass',
          status: 'FAIL',
          severity: 'CRITICAL',
          description: 'JWT implementation accepts tokens with "none" algorithm',
          evidence: { noneAlgToken, decoded },
          recommendation: 'Explicitly reject tokens with "none" algorithm in production',
        });
      } catch (error) {
        this.addResult({
          testName: 'None Algorithm Bypass',
          status: 'PASS',
          severity: 'HIGH',
          description: 'None algorithm tokens properly rejected',
          evidence: { error: error.message },
        });
      }

      // Test empty signature bypass
      const emptySignatureToken = `${header}.${payload}.`;

      try {
        const decoded = verifyToken(emptySignatureToken);

        this.addResult({
          testName: 'Empty Signature Bypass',
          status: 'FAIL',
          severity: 'CRITICAL',
          description: 'JWT implementation accepts tokens with empty signature',
          evidence: { emptySignatureToken, decoded },
          recommendation:
            'Validate signature presence for all algorithms except explicitly allowed none',
        });
      } catch (error) {
        this.addResult({
          testName: 'Empty Signature Bypass',
          status: 'PASS',
          severity: 'HIGH',
          description: 'Empty signature tokens properly rejected',
        });
      }
    } catch (error) {
      this.addResult({
        testName: 'None Algorithm Test Suite',
        status: 'WARNING',
        severity: 'MEDIUM',
        description: 'None algorithm tests could not be completed',
        evidence: { error: error.message },
      });
    }
  }

  /**
   * Test Signature Validation Bypasses
   */
  private async testSignatureBypass(): Promise<void> {
    console.log('üîç Testing Signature Validation Bypasses...');

    try {
      const validToken = generateToken({
        userId: 'user123',
        email: 'test@example.com',
        role: 'user',
      });

      const [header, payload, signature] = validToken.split('.');

      // Test 1: Invalid signature
      const invalidSignature = Buffer.from('invalid_signature').toString('base64url');
      const tokenWithInvalidSignature = `${header}.${payload}.${invalidSignature}`;

      try {
        const decoded = verifyToken(tokenWithInvalidSignature);

        this.addResult({
          testName: 'Invalid Signature Acceptance',
          status: 'FAIL',
          severity: 'CRITICAL',
          description: 'JWT implementation accepts tokens with invalid signatures',
          evidence: { tokenWithInvalidSignature, decoded },
          recommendation: 'Implement proper signature validation',
        });
      } catch (error) {
        this.addResult({
          testName: 'Invalid Signature Rejection',
          status: 'PASS',
          severity: 'HIGH',
          description: 'Invalid signatures properly rejected',
        });
      }

      // Test 2: Modified payload with original signature
      const originalPayload = JSON.parse(Buffer.from(payload, 'base64url').toString());
      const modifiedPayload = { ...originalPayload, role: 'admin' };
      const modifiedPayloadB64 = Buffer.from(JSON.stringify(modifiedPayload)).toString('base64url');
      const tokenWithModifiedPayload = `${header}.${modifiedPayloadB64}.${signature}`;

      try {
        const decoded = verifyToken(tokenWithModifiedPayload);

        this.addResult({
          testName: 'Modified Payload with Original Signature',
          status: 'FAIL',
          severity: 'CRITICAL',
          description: 'JWT implementation accepts modified payload with original signature',
          evidence: { tokenWithModifiedPayload, decoded },
          recommendation: 'Ensure signature validation covers entire token content',
        });
      } catch (error) {
        this.addResult({
          testName: 'Modified Payload Detection',
          status: 'PASS',
          severity: 'HIGH',
          description: 'Modified payload properly detected and rejected',
        });
      }
    } catch (error) {
      this.addResult({
        testName: 'Signature Bypass Test Suite',
        status: 'WARNING',
        severity: 'MEDIUM',
        description: 'Signature bypass tests could not be completed',
        evidence: { error: error.message },
      });
    }
  }

  /**
   * Test Token Forgery Attempts
   */
  private async testTokenForgery(): Promise<void> {
    console.log('üîç Testing Token Forgery Attempts...');

    try {
      // Test weak secret brute force
      const weakSecrets = [
        'secret',
        'password',
        '123456',
        'admin',
        'test',
        'key',
        'jwt',
        'token',
        'qwerty',
        'password123',
      ];

      const forgedPayload = {
        userId: 'attacker',
        email: 'attacker@evil.com',
        role: 'admin',
        exp: Math.floor(Date.now() / 1000) + 3600,
      };

      let successfulForgery = false;
      let usedSecret = '';

      for (const secret of weakSecrets) {
        try {
          const forgedToken = jwt.sign(forgedPayload, secret, { algorithm: 'HS256' });
          const decoded = verifyToken(forgedToken);

          successfulForgery = true;
          usedSecret = secret;
          break;
        } catch (error) {
          // Token rejected, continue testing
        }
      }

      if (successfulForgery) {
        this.addResult({
          testName: 'Weak Secret Brute Force',
          status: 'FAIL',
          severity: 'CRITICAL',
          description: 'JWT uses weak secret that can be brute-forced',
          evidence: { usedSecret, forgedPayload },
          recommendation:
            'Use cryptographically strong, randomly generated secrets (minimum 256 bits)',
        });
      } else {
        this.addResult({
          testName: 'Weak Secret Resistance',
          status: 'PASS',
          severity: 'HIGH',
          description: 'JWT secret resistant to common weak secret attacks',
        });
      }

      // Test predictable secret patterns
      const predictableSecrets = [
        'medianest_secret',
        'medianest123',
        'jwt_secret_key',
        process.env.APP_NAME + '_secret',
        'default_jwt_secret',
      ];

      let predictableSecretFound = false;

      for (const secret of predictableSecrets) {
        try {
          const predictableToken = jwt.sign(forgedPayload, secret, { algorithm: 'HS256' });
          const decoded = verifyToken(predictableToken);

          predictableSecretFound = true;
          break;
        } catch (error) {
          // Token rejected, continue testing
        }
      }

      if (predictableSecretFound) {
        this.addResult({
          testName: 'Predictable Secret Pattern',
          status: 'FAIL',
          severity: 'HIGH',
          description: 'JWT uses predictable secret pattern',
          evidence: { predictableSecrets },
          recommendation: 'Use randomly generated secrets without predictable patterns',
        });
      } else {
        this.addResult({
          testName: 'Predictable Secret Resistance',
          status: 'PASS',
          severity: 'MEDIUM',
          description: 'JWT secret does not follow predictable patterns',
        });
      }
    } catch (error) {
      this.addResult({
        testName: 'Token Forgery Test Suite',
        status: 'WARNING',
        severity: 'MEDIUM',
        description: 'Token forgery tests could not be completed',
        evidence: { error: error.message },
      });
    }
  }

  /**
   * Test Key Confusion Attacks
   */
  private async testKeyConfusion(): Promise<void> {
    console.log('üîç Testing Key Confusion Attacks...');

    try {
      // Test using different key for verification
      const originalKey = 'original_secret_key';
      const confusionKey = 'confusion_attack_key';

      const payload = { userId: 'user123', role: 'user' };

      // Create token with original key
      const tokenWithOriginalKey = jwt.sign(payload, originalKey, { algorithm: 'HS256' });

      try {
        // Try to verify with different key
        const decoded = jwt.verify(tokenWithOriginalKey, confusionKey, { algorithms: ['HS256'] });

        this.addResult({
          testName: 'Key Confusion Attack',
          status: 'FAIL',
          severity: 'CRITICAL',
          description: 'JWT implementation vulnerable to key confusion',
          evidence: { tokenWithOriginalKey, decoded },
          recommendation: 'Implement consistent key management and validation',
        });
      } catch (error) {
        this.addResult({
          testName: 'Key Confusion Resistance',
          status: 'PASS',
          severity: 'HIGH',
          description: 'Key confusion attack properly rejected',
        });
      }

      // Test key rotation security
      const rotationResult = jwtFacade.rotateTokenIfNeeded(
        tokenWithOriginalKey,
        payload as JWTPayload,
      );

      if (rotationResult) {
        try {
          // Verify old token is still accepted after rotation
          const decoded = verifyToken(tokenWithOriginalKey);

          this.addResult({
            testName: 'Key Rotation Security Gap',
            status: 'WARNING',
            severity: 'MEDIUM',
            description: 'Old tokens still accepted after key rotation',
            evidence: { oldToken: tokenWithOriginalKey, decoded },
            recommendation: 'Implement token revocation or short grace period for key rotation',
          });
        } catch (error) {
          this.addResult({
            testName: 'Key Rotation Security',
            status: 'PASS',
            severity: 'LOW',
            description: 'Key rotation properly invalidates old tokens',
          });
        }
      }
    } catch (error) {
      this.addResult({
        testName: 'Key Confusion Test Suite',
        status: 'WARNING',
        severity: 'MEDIUM',
        description: 'Key confusion tests could not be completed',
        evidence: { error: error.message },
      });
    }
  }

  /**
   * Test Timing Attack Vulnerabilities
   */
  private async testTimingAttacks(): Promise<void> {
    console.log('üîç Testing Timing Attack Vulnerabilities...');

    try {
      const validToken = generateToken({
        userId: 'user123',
        email: 'test@example.com',
        role: 'user',
      });

      const invalidTokens = [
        'invalid.token.signature',
        'completely.invalid.jwt',
        'short',
        'very.long.token.that.should.not.validate.properly.and.might.reveal.timing.information',
        validToken.slice(0, -5) + 'XXXXX', // Valid structure, invalid signature
      ];

      const timings: number[] = [];

      // Measure timing for valid token
      const validTimings: number[] = [];
      for (let i = 0; i < 10; i++) {
        const start = performance.now();
        try {
          verifyToken(validToken);
        } catch (error) {
          // Ignore errors for timing measurement
        }
        const end = performance.now();
        validTimings.push(end - start);
      }

      // Measure timing for invalid tokens
      const invalidTimings: number[] = [];
      for (const invalidToken of invalidTokens) {
        const tokenTimings: number[] = [];
        for (let i = 0; i < 10; i++) {
          const start = performance.now();
          try {
            verifyToken(invalidToken);
          } catch (error) {
            // Ignore errors for timing measurement
          }
          const end = performance.now();
          tokenTimings.push(end - start);
        }
        invalidTimings.push(...tokenTimings);
      }

      const avgValidTime = validTimings.reduce((a, b) => a + b, 0) / validTimings.length;
      const avgInvalidTime = invalidTimings.reduce((a, b) => a + b, 0) / invalidTimings.length;
      const timingDifference = Math.abs(avgValidTime - avgInvalidTime);

      // If timing difference is significant (>10ms), it might be vulnerable
      if (timingDifference > 10) {
        this.addResult({
          testName: 'Timing Attack Vulnerability',
          status: 'WARNING',
          severity: 'MEDIUM',
          description: 'Significant timing difference detected between valid and invalid tokens',
          evidence: {
            avgValidTime: avgValidTime.toFixed(3),
            avgInvalidTime: avgInvalidTime.toFixed(3),
            difference: timingDifference.toFixed(3),
          },
          recommendation: 'Implement constant-time comparison for token validation',
        });
      } else {
        this.addResult({
          testName: 'Timing Attack Resistance',
          status: 'PASS',
          severity: 'LOW',
          description: 'No significant timing differences detected',
        });
      }
    } catch (error) {
      this.addResult({
        testName: 'Timing Attack Test Suite',
        status: 'WARNING',
        severity: 'LOW',
        description: 'Timing attack tests could not be completed',
        evidence: { error: error.message },
      });
    }
  }

  /**
   * Test Token Expiration Handling
   */
  private async testExpirationHandling(): Promise<void> {
    console.log('üîç Testing Token Expiration Handling...');

    try {
      // Test expired token acceptance
      const expiredPayload = {
        userId: 'user123',
        email: 'test@example.com',
        role: 'user',
        exp: Math.floor(Date.now() / 1000) - 3600, // Expired 1 hour ago
      };

      const expiredToken = jwt.sign(expiredPayload, 'test-secret', { algorithm: 'HS256' });

      try {
        const decoded = verifyToken(expiredToken);

        this.addResult({
          testName: 'Expired Token Acceptance',
          status: 'FAIL',
          severity: 'HIGH',
          description: 'JWT implementation accepts expired tokens',
          evidence: { expiredToken, decoded, expiredAt: new Date(expiredPayload.exp * 1000) },
          recommendation: 'Implement proper expiration validation',
        });
      } catch (error) {
        this.addResult({
          testName: 'Expired Token Rejection',
          status: 'PASS',
          severity: 'HIGH',
          description: 'Expired tokens properly rejected',
        });
      }

      // Test token without expiration
      const noExpPayload = {
        userId: 'user123',
        email: 'test@example.com',
        role: 'user',
        // No exp claim
      };

      const noExpToken = jwt.sign(noExpPayload, 'test-secret', { algorithm: 'HS256' });

      try {
        const decoded = verifyToken(noExpToken);

        this.addResult({
          testName: 'No Expiration Token',
          status: 'WARNING',
          severity: 'MEDIUM',
          description: 'JWT implementation accepts tokens without expiration',
          evidence: { noExpToken, decoded },
          recommendation: 'Require expiration claim for all tokens',
        });
      } catch (error) {
        this.addResult({
          testName: 'No Expiration Token Rejection',
          status: 'PASS',
          severity: 'MEDIUM',
          description: 'Tokens without expiration properly handled',
        });
      }

      // Test future-dated token (nbf - not before)
      const futurePayload = {
        userId: 'user123',
        email: 'test@example.com',
        role: 'user',
        nbf: Math.floor(Date.now() / 1000) + 3600, // Valid 1 hour from now
        exp: Math.floor(Date.now() / 1000) + 7200,
      };

      const futureToken = jwt.sign(futurePayload, 'test-secret', { algorithm: 'HS256' });

      try {
        const decoded = verifyToken(futureToken);

        this.addResult({
          testName: 'Future-Dated Token Acceptance',
          status: 'WARNING',
          severity: 'MEDIUM',
          description: 'JWT implementation accepts tokens valid in future',
          evidence: { futureToken, decoded, validFrom: new Date(futurePayload.nbf * 1000) },
          recommendation: 'Implement not-before (nbf) claim validation',
        });
      } catch (error) {
        this.addResult({
          testName: 'Future-Dated Token Rejection',
          status: 'PASS',
          severity: 'MEDIUM',
          description: 'Future-dated tokens properly rejected',
        });
      }
    } catch (error) {
      this.addResult({
        testName: 'Expiration Handling Test Suite',
        status: 'WARNING',
        severity: 'MEDIUM',
        description: 'Expiration handling tests could not be completed',
        evidence: { error: error.message },
      });
    }
  }

  /**
   * Test Refresh Token Security
   */
  private async testRefreshTokenSecurity(): Promise<void> {
    console.log('üîç Testing Refresh Token Security...');

    try {
      // Generate refresh token
      const refreshToken = generateRefreshToken({ userId: 'user123', sessionId: 'session123' });

      // Test refresh token replay
      try {
        const result1 = jwtFacade.verifyRefreshToken(refreshToken);
        const result2 = jwtFacade.verifyRefreshToken(refreshToken);

        if (result1 && result2) {
          this.addResult({
            testName: 'Refresh Token Replay',
            status: 'WARNING',
            severity: 'MEDIUM',
            description: 'Refresh tokens can be reused multiple times',
            evidence: { refreshToken, result1, result2 },
            recommendation: 'Implement one-time use refresh tokens with rotation',
          });
        }
      } catch (error) {
        this.addResult({
          testName: 'Refresh Token Single Use',
          status: 'PASS',
          severity: 'MEDIUM',
          description: 'Refresh tokens properly restricted to single use',
        });
      }

      // Test refresh token as access token
      try {
        const decoded = verifyToken(refreshToken);

        this.addResult({
          testName: 'Refresh Token as Access Token',
          status: 'FAIL',
          severity: 'HIGH',
          description: 'Refresh token accepted as access token',
          evidence: { refreshToken, decoded },
          recommendation: 'Implement separate validation for refresh and access tokens',
        });
      } catch (error) {
        this.addResult({
          testName: 'Token Type Validation',
          status: 'PASS',
          severity: 'HIGH',
          description: 'Refresh tokens properly distinguished from access tokens',
        });
      }

      // Test refresh token storage
      if (refreshToken.length < 32) {
        this.addResult({
          testName: 'Refresh Token Entropy',
          status: 'WARNING',
          severity: 'MEDIUM',
          description: 'Refresh token may have insufficient entropy',
          evidence: { tokenLength: refreshToken.length },
          recommendation: 'Use at least 256 bits of entropy for refresh tokens',
        });
      } else {
        this.addResult({
          testName: 'Refresh Token Entropy',
          status: 'PASS',
          severity: 'LOW',
          description: 'Refresh token has sufficient entropy',
        });
      }
    } catch (error) {
      this.addResult({
        testName: 'Refresh Token Security Test Suite',
        status: 'WARNING',
        severity: 'MEDIUM',
        description: 'Refresh token security tests could not be completed',
        evidence: { error: error.message },
      });
    }
  }

  /**
   * Test Session Management Security
   */
  private async testSessionManagement(): Promise<void> {
    console.log('üîç Testing Session Management Security...');

    try {
      const token = generateToken({
        userId: 'user123',
        email: 'test@example.com',
        role: 'user',
      });

      // Test session fixation
      const metadata1 = jwtFacade.getTokenMetadata(token);
      const token2 = generateToken({
        userId: 'user123',
        email: 'test@example.com',
        role: 'user',
      });
      const metadata2 = jwtFacade.getTokenMetadata(token2);

      if (metadata1.sessionId === metadata2.sessionId) {
        this.addResult({
          testName: 'Session Fixation Vulnerability',
          status: 'FAIL',
          severity: 'HIGH',
          description: 'Session IDs are predictable or reused',
          evidence: { metadata1, metadata2 },
          recommendation: 'Generate unique, unpredictable session IDs for each authentication',
        });
      } else {
        this.addResult({
          testName: 'Session ID Uniqueness',
          status: 'PASS',
          severity: 'HIGH',
          description: 'Session IDs are unique and unpredictable',
        });
      }

      // Test concurrent sessions
      const concurrentToken = generateToken(
        {
          userId: 'user123',
          email: 'test@example.com',
          role: 'user',
        },
        false,
        { sessionId: 'concurrent-session' },
      );

      try {
        const decoded1 = verifyToken(token);
        const decoded2 = verifyToken(concurrentToken);

        this.addResult({
          testName: 'Concurrent Session Management',
          status: 'PASS',
          severity: 'LOW',
          description: 'Multiple concurrent sessions allowed',
          evidence: { session1: decoded1.sessionId, session2: decoded2.sessionId },
          recommendation: 'Consider implementing session limits if not intended',
        });
      } catch (error) {
        this.addResult({
          testName: 'Session Conflict',
          status: 'WARNING',
          severity: 'MEDIUM',
          description: 'Concurrent sessions may cause conflicts',
        });
      }

      // Test token blacklisting
      const tokenId = jwtFacade.getTokenMetadata(token).tokenId;
      if (tokenId) {
        jwtFacade.blacklistToken(tokenId);

        if (jwtFacade.isTokenBlacklisted(tokenId)) {
          this.addResult({
            testName: 'Token Blacklisting',
            status: 'PASS',
            severity: 'HIGH',
            description: 'Token blacklisting mechanism works correctly',
          });
        } else {
          this.addResult({
            testName: 'Token Blacklisting Failure',
            status: 'FAIL',
            severity: 'HIGH',
            description: 'Token blacklisting mechanism failed',
            recommendation: 'Implement proper token revocation mechanism',
          });
        }
      }
    } catch (error) {
      this.addResult({
        testName: 'Session Management Test Suite',
        status: 'WARNING',
        severity: 'MEDIUM',
        description: 'Session management tests could not be completed',
        evidence: { error: error.message },
      });
    }
  }

  /**
   * Test Token Storage and Transmission Security
   */
  private async testTokenStorageTransmission(): Promise<void> {
    console.log('üîç Testing Token Storage and Transmission Security...');

    try {
      const token = generateToken({
        userId: 'user123',
        email: 'test@example.com',
        role: 'user',
      });

      // Test token exposure in logs
      const tokenInUrl = `https://api.example.com/data?token=${token}`;

      this.addResult({
        testName: 'Token URL Exposure Risk',
        status: 'WARNING',
        severity: 'HIGH',
        description: 'Tokens should not be transmitted in URLs',
        evidence: { exampleUrl: tokenInUrl },
        recommendation: 'Use Authorization header or secure cookies for token transmission',
      });

      // Test token size (large tokens may cause issues)
      const tokenSize = Buffer.byteLength(token, 'utf8');

      if (tokenSize > 8192) {
        // Common HTTP header size limit
        this.addResult({
          testName: 'Token Size Warning',
          status: 'WARNING',
          severity: 'LOW',
          description: 'Token size may exceed HTTP header limits',
          evidence: { tokenSize },
          recommendation: 'Consider reducing token payload size or using token references',
        });
      } else {
        this.addResult({
          testName: 'Token Size Appropriate',
          status: 'PASS',
          severity: 'LOW',
          description: 'Token size is within acceptable limits',
        });
      }

      // Test sensitive information in token
      const decoded = jwtFacade.decodeToken(token);
      const sensitiveFields = ['password', 'ssn', 'creditCard', 'privateKey'];
      const foundSensitive = sensitiveFields.filter(
        (field) => decoded && JSON.stringify(decoded).toLowerCase().includes(field),
      );

      if (foundSensitive.length > 0) {
        this.addResult({
          testName: 'Sensitive Information in Token',
          status: 'FAIL',
          severity: 'HIGH',
          description: 'Token contains sensitive information',
          evidence: { foundSensitive, decoded },
          recommendation: 'Remove sensitive information from JWT payload',
        });
      } else {
        this.addResult({
          testName: 'Token Information Security',
          status: 'PASS',
          severity: 'HIGH',
          description: 'No obvious sensitive information in token payload',
        });
      }
    } catch (error) {
      this.addResult({
        testName: 'Storage and Transmission Test Suite',
        status: 'WARNING',
        severity: 'MEDIUM',
        description: 'Storage and transmission tests could not be completed',
        evidence: { error: error.message },
      });
    }
  }

  /**
   * Add test result to results array
   */
  private addResult(result: SecurityTestResult): void {
    this.results.push(result);

    const statusIcon = result.status === 'PASS' ? '‚úÖ' : result.status === 'FAIL' ? '‚ùå' : '‚ö†Ô∏è';
    const severityIcon =
      result.severity === 'CRITICAL'
        ? 'üö®'
        : result.severity === 'HIGH'
          ? 'üî¥'
          : result.severity === 'MEDIUM'
            ? 'üü°'
            : 'üü¢';

    console.log(`${statusIcon} ${severityIcon} ${result.testName}: ${result.description}`);

    if (result.recommendation) {
      console.log(`   üí° ${result.recommendation}`);
    }
    console.log('');
  }

  /**
   * Generate comprehensive security report
   */
  generateSecurityReport(): string {
    const criticalIssues = this.results.filter((r) => r.severity === 'CRITICAL');
    const highIssues = this.results.filter((r) => r.severity === 'HIGH');
    const mediumIssues = this.results.filter((r) => r.severity === 'MEDIUM');
    const lowIssues = this.results.filter((r) => r.severity === 'LOW');

    const passedTests = this.results.filter((r) => r.status === 'PASS').length;
    const failedTests = this.results.filter((r) => r.status === 'FAIL').length;
    const warningTests = this.results.filter((r) => r.status === 'WARNING').length;

    return `
# JWT Security Assessment Report
## MediaNest Production Security Validation

### Executive Summary
- **Total Tests**: ${this.results.length}
- **Passed**: ${passedTests}
- **Failed**: ${failedTests}
- **Warnings**: ${warningTests}

### Security Issues by Severity
- **Critical**: ${criticalIssues.length}
- **High**: ${highIssues.length}
- **Medium**: ${mediumIssues.length}
- **Low**: ${lowIssues.length}

### Critical Issues
${criticalIssues
  .map(
    (issue) => `
#### ${issue.testName}
- **Status**: ${issue.status}
- **Description**: ${issue.description}
- **Recommendation**: ${issue.recommendation || 'No recommendation provided'}
${issue.evidence ? `- **Evidence**: ${JSON.stringify(issue.evidence, null, 2)}` : ''}
`,
  )
  .join('\n')}

### High Priority Issues
${highIssues
  .filter((i) => i.status !== 'PASS')
  .map(
    (issue) => `
#### ${issue.testName}
- **Status**: ${issue.status}
- **Description**: ${issue.description}
- **Recommendation**: ${issue.recommendation || 'No recommendation provided'}
`,
  )
  .join('\n')}

### Recommendations
1. **Immediate Actions Required**:
   - Fix all CRITICAL severity issues immediately
   - Implement proper algorithm validation
   - Use cryptographically strong JWT secrets
   
2. **High Priority Actions**:
   - Address HIGH severity vulnerabilities
   - Implement proper token expiration handling
   - Enhance refresh token security
   
3. **Medium Priority Actions**:
   - Review session management practices
   - Implement timing attack protections
   - Optimize token storage and transmission

### Overall Security Rating
${this.calculateSecurityRating()}

---
*Generated on ${new Date().toISOString()}*
*MediaNest JWT Security Validator*
`;
  }

  /**
   * Calculate overall security rating
   */
  private calculateSecurityRating(): string {
    const critical = this.results.filter(
      (r) => r.severity === 'CRITICAL' && r.status === 'FAIL',
    ).length;
    const high = this.results.filter((r) => r.severity === 'HIGH' && r.status === 'FAIL').length;
    const medium = this.results.filter(
      (r) => r.severity === 'MEDIUM' && r.status === 'FAIL',
    ).length;

    if (critical > 0) {
      return 'üö® **CRITICAL RISK** - Immediate action required';
    } else if (high > 2) {
      return 'üî¥ **HIGH RISK** - Address high priority issues immediately';
    } else if (high > 0 || medium > 3) {
      return 'üü° **MEDIUM RISK** - Security improvements needed';
    } else {
      return 'üü¢ **LOW RISK** - Good security posture with minor improvements needed';
    }
  }
}

export default JWTSecurityValidator;
