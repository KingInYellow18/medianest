/**\n * Database Security Configuration and Validation\n * Comprehensive security hardening for PostgreSQL and Redis connections\n * \n * @author MediaNest Security Team\n * @version 1.0.0\n * @since 2025-09-11\n */\n\nconst { z } = require('zod');\nconst { createServiceLogger } = require('../../shared/src/config/logging.config');\n\n/**\n * PostgreSQL SSL Configuration Schema\n */\nconst PostgresSSLConfigSchema = z.object({\n    enabled: z.coerce.boolean().default(true),\n    rejectUnauthorized: z.coerce.boolean().default(true),\n    ca: z.string().optional(),\n    cert: z.string().optional(),\n    key: z.string().optional(),\n    servername: z.string().optional(),\n    checkServerIdentity: z.boolean().default(true)\n});\n\n/**\n * Redis TLS Configuration Schema\n */\nconst RedisTLSConfigSchema = z.object({\n    enabled: z.coerce.boolean().default(false),\n    rejectUnauthorized: z.coerce.boolean().default(true),\n    ca: z.string().optional(),\n    cert: z.string().optional(),\n    key: z.string().optional(),\n    servername: z.string().optional()\n});\n\n/**\n * Database Security Configuration Manager\n */\nclass DatabaseSecurityManager {\n    constructor() {\n        this.logger = createServiceLogger('database-security');\n    }\n\n    /**\n     * Generate secure PostgreSQL connection string with SSL/TLS\n     * @param {Object} config - Database configuration\n     * @param {Object} sslConfig - SSL configuration options\n     * @returns {string} - Secure connection string\n     */\n    generateSecurePostgresUrl(config, sslConfig = {}) {\n        const validated = PostgresSSLConfigSchema.parse(sslConfig);\n        \n        // Base connection parameters\n        const baseUrl = config.DATABASE_URL || \n            `postgresql://${config.DB_USER}:${config.DB_PASSWORD}@${config.DB_HOST}:${config.DB_PORT}/${config.DB_NAME}`;\n        \n        const url = new URL(baseUrl);\n        \n        // Add SSL/TLS parameters for production\n        if (process.env.NODE_ENV === 'production' || validated.enabled) {\n            url.searchParams.set('sslmode', 'require');\n            \n            if (validated.rejectUnauthorized === false) {\n                url.searchParams.set('sslrootcert', 'system');\n            }\n            \n            // Connection pool optimization for production\n            url.searchParams.set('connection_limit', process.env.DB_POOL_MAX || '20');\n            url.searchParams.set('pool_timeout', process.env.DB_POOL_TIMEOUT || '30');\n            url.searchParams.set('statement_timeout', process.env.DB_STATEMENT_TIMEOUT || '60000');\n            url.searchParams.set('idle_in_transaction_session_timeout', '300000');\n        }\n        \n        this.logger.info('Generated secure PostgreSQL connection string', {\n            sslEnabled: validated.enabled,\n            rejectUnauthorized: validated.rejectUnauthorized,\n            host: url.hostname,\n            port: url.port,\n            database: url.pathname.slice(1)\n        });\n        \n        return url.toString();\n    }\n\n    /**\n     * Generate secure Redis connection options with TLS\n     * @param {Object} config - Redis configuration\n     * @param {Object} tlsConfig - TLS configuration options\n     * @returns {Object} - Secure Redis options\n     */\n    generateSecureRedisOptions(config, tlsConfig = {}) {\n        const validated = RedisTLSConfigSchema.parse(tlsConfig);\n        \n        const options = {\n            host: config.REDIS_HOST,\n            port: config.REDIS_PORT,\n            password: config.REDIS_PASSWORD,\n            db: config.REDIS_DB || 0,\n            \n            // Security settings\n            enableOfflineQueue: false, // Prevent command queuing when disconnected\n            showFriendlyErrorStack: process.env.NODE_ENV !== 'production',\n            \n            // Connection security\n            connectTimeout: 10000,\n            commandTimeout: 5000,\n            lazyConnect: true,\n            maxRetriesPerRequest: 3,\n            \n            // Retry strategy with exponential backoff\n            retryStrategy: (times) => {\n                const delay = Math.min(times * 50, 2000);\n                return delay;\n            },\n            \n            // Keep-alive configuration\n            family: 4,\n            keepAlive: true,\n            \n            // Auto-pipelining for performance\n            enableAutoPipelining: true\n        };\n        \n        // Add TLS configuration for production or when explicitly enabled\n        if (process.env.NODE_ENV === 'production' || validated.enabled) {\n            if (validated.enabled) {\n                options.tls = {\n                    rejectUnauthorized: validated.rejectUnauthorized,\n                    servername: validated.servername || config.REDIS_HOST\n                };\n                \n                // Add certificate files if provided\n                if (validated.ca) options.tls.ca = validated.ca;\n                if (validated.cert) options.tls.cert = validated.cert;\n                if (validated.key) options.tls.key = validated.key;\n            }\n        }\n        \n        this.logger.info('Generated secure Redis options', {\n            tlsEnabled: validated.enabled,\n            host: config.REDIS_HOST,\n            port: config.REDIS_PORT,\n            db: config.REDIS_DB || 0,\n            passwordProtected: !!config.REDIS_PASSWORD\n        });\n        \n        return options;\n    }\n\n    /**\n     * Validate database security configuration\n     * @param {Object} config - Database configuration\n     * @returns {Object} - Validation results\n     */\n    validateDatabaseSecurity(config) {\n        const results = {\n            postgresql: { secure: true, issues: [] },\n            redis: { secure: true, issues: [] },\n            overall: { secure: true, criticalIssues: 0, warnings: 0 }\n        };\n        \n        // PostgreSQL Security Validation\n        this.validatePostgresqlSecurity(config, results.postgresql);\n        \n        // Redis Security Validation\n        this.validateRedisSecurity(config, results.redis);\n        \n        // Calculate overall security status\n        results.overall.secure = results.postgresql.secure && results.redis.secure;\n        results.overall.criticalIssues = \n            results.postgresql.issues.filter(i => i.severity === 'critical').length +\n            results.redis.issues.filter(i => i.severity === 'critical').length;\n        results.overall.warnings = \n            results.postgresql.issues.filter(i => i.severity === 'warning').length +\n            results.redis.issues.filter(i => i.severity === 'warning').length;\n        \n        this.logger.info('Database security validation completed', {\n            secure: results.overall.secure,\n            criticalIssues: results.overall.criticalIssues,\n            warnings: results.overall.warnings\n        });\n        \n        return results;\n    }\n\n    /**\n     * Validate PostgreSQL security configuration\n     * @private\n     */\n    validatePostgresqlSecurity(config, results) {\n        // Check for DATABASE_URL or connection parameters\n        if (!config.DATABASE_URL && (!config.DB_HOST || !config.DB_USER || !config.DB_PASSWORD)) {\n            results.issues.push({\n                type: 'configuration',\n                severity: 'critical',\n                message: 'PostgreSQL connection parameters not configured',\n                recommendation: 'Set DATABASE_URL or individual DB_* environment variables'\n            });\n            results.secure = false;\n        }\n        \n        // Production SSL/TLS validation\n        if (process.env.NODE_ENV === 'production') {\n            if (config.DATABASE_URL) {\n                const url = new URL(config.DATABASE_URL);\n                if (!url.searchParams.has('sslmode') || url.searchParams.get('sslmode') !== 'require') {\n                    results.issues.push({\n                        type: 'ssl',\n                        severity: 'critical',\n                        message: 'SSL/TLS not enforced for production PostgreSQL connection',\n                        recommendation: 'Add sslmode=require to DATABASE_URL parameter'\n                    });\n                    results.secure = false;\n                }\n            }\n            \n            // Check for SSL certificate configuration\n            if (!process.env.DB_SSL_CA && !process.env.DB_SSL_DISABLE) {\n                results.issues.push({\n                    type: 'ssl',\n                    severity: 'warning',\n                    message: 'PostgreSQL SSL certificate authority not configured',\n                    recommendation: 'Set DB_SSL_CA environment variable or DB_SSL_DISABLE=true if using trusted certificates'\n                });\n            }\n        }\n        \n        // Connection pool validation\n        const poolMax = parseInt(process.env.DB_POOL_MAX) || 20;\n        if (poolMax > 50) {\n            results.issues.push({\n                type: 'performance',\n                severity: 'warning',\n                message: 'PostgreSQL connection pool size may be too large',\n                recommendation: 'Consider reducing DB_POOL_MAX for better resource management'\n            });\n        }\n        \n        // Weak password detection (basic)\n        if (config.DB_PASSWORD && config.DB_PASSWORD.length < 12) {\n            results.issues.push({\n                type: 'authentication',\n                severity: 'warning',\n                message: 'PostgreSQL password may be too weak',\n                recommendation: 'Use passwords with at least 12 characters, mixed case, numbers, and symbols'\n            });\n        }\n    }\n\n    /**\n     * Validate Redis security configuration\n     * @private\n     */\n    validateRedisSecurity(config, results) {\n        // Redis connection validation\n        if (!config.REDIS_URL && !config.REDIS_HOST) {\n            results.issues.push({\n                type: 'configuration',\n                severity: 'warning',\n                message: 'Redis connection not configured',\n                recommendation: 'Configure REDIS_URL or REDIS_HOST for caching functionality'\n            });\n        }\n        \n        // Production authentication validation\n        if (process.env.NODE_ENV === 'production') {\n            if (!config.REDIS_PASSWORD && !config.REDIS_URL?.includes('auth')) {\n                results.issues.push({\n                    type: 'authentication',\n                    severity: 'critical',\n                    message: 'Redis authentication not configured for production',\n                    recommendation: 'Set REDIS_PASSWORD or include password in REDIS_URL'\n                });\n                results.secure = false;\n            }\n            \n            // TLS validation\n            if (!process.env.REDIS_TLS_ENABLED && !process.env.REDIS_TLS_DISABLE) {\n                results.issues.push({\n                    type: 'encryption',\n                    severity: 'warning',\n                    message: 'Redis TLS encryption not explicitly configured',\n                    recommendation: 'Set REDIS_TLS_ENABLED=true for encrypted connections or REDIS_TLS_DISABLE=true if not needed'\n                });\n            }\n        }\n        \n        // Redis configuration security\n        const maxRetries = parseInt(config.REDIS_MAX_RETRIES) || 3;\n        if (maxRetries > 10) {\n            results.issues.push({\n                type: 'configuration',\n                severity: 'warning',\n                message: 'Redis max retries set too high',\n                recommendation: 'Consider reducing REDIS_MAX_RETRIES to prevent connection storms'\n            });\n        }\n        \n        // Weak Redis password detection\n        if (config.REDIS_PASSWORD && config.REDIS_PASSWORD.length < 16) {\n            results.issues.push({\n                type: 'authentication',\n                severity: 'warning',\n                message: 'Redis password may be too weak',\n                recommendation: 'Use Redis passwords with at least 16 characters for better security'\n            });\n        }\n    }\n\n    /**\n     * Generate database security report\n     * @param {Object} validationResults - Results from validateDatabaseSecurity\n     * @returns {string} - Security report\n     */\n    generateSecurityReport(validationResults) {\n        const { postgresql, redis, overall } = validationResults;\n        \n        let report = '\\n=== DATABASE SECURITY REPORT ===\\n\\n';\n        \n        // Overall status\n        report += `Overall Security Status: ${overall.secure ? '✅ SECURE' : '❌ ISSUES DETECTED'}\\n`;\n        report += `Critical Issues: ${overall.criticalIssues}\\n`;\n        report += `Warnings: ${overall.warnings}\\n\\n`;\n        \n        // PostgreSQL section\n        report += `--- PostgreSQL Security ---\\n`;\n        report += `Status: ${postgresql.secure ? '✅ Secure' : '⚠️ Issues Found'}\\n`;\n        if (postgresql.issues.length > 0) {\n            postgresql.issues.forEach(issue => {\n                const icon = issue.severity === 'critical' ? '🚨' : '⚠️';\n                report += `${icon} ${issue.type.toUpperCase()}: ${issue.message}\\n`;\n                report += `   → ${issue.recommendation}\\n`;\n            });\n        }\n        report += '\\n';\n        \n        // Redis section\n        report += `--- Redis Security ---\\n`;\n        report += `Status: ${redis.secure ? '✅ Secure' : '⚠️ Issues Found'}\\n`;\n        if (redis.issues.length > 0) {\n            redis.issues.forEach(issue => {\n                const icon = issue.severity === 'critical' ? '🚨' : '⚠️';\n                report += `${icon} ${issue.type.toUpperCase()}: ${issue.message}\\n`;\n                report += `   → ${issue.recommendation}\\n`;\n            });\n        }\n        \n        report += '\\n=== END REPORT ===\\n';\n        \n        return report;\n    }\n}\n\nmodule.exports = {\n    DatabaseSecurityManager,\n    PostgresSSLConfigSchema,\n    RedisTLSConfigSchema\n};\n