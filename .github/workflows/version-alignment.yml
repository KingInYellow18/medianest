name: Advanced Version Alignment and Workspace Coordination

on:
  push:
    branches: [ main, development ]
    paths:
      - '**/package.json'
      - 'package-lock.json'
      - '.github/workflows/version-alignment.yml'
  pull_request:
    branches: [ main, development ]
    paths:
      - '**/package.json'
      - 'package-lock.json'
  schedule:
    # Run weekly on Sundays at 3 AM UTC
    - cron: '0 3 * * 0'
  workflow_dispatch:
    inputs:
      strategy:
        description: 'Version alignment strategy'
        required: true
        default: 'conservative'
        type: choice
        options:
          - conservative
          - aggressive
          - latest
          - specific
      target_version:
        description: 'Specific version (for specific strategy)'
        required: false
        type: string
      force_alignment:
        description: 'Force alignment even with breaking changes'
        required: false
        type: boolean
        default: false

env:
  NODE_VERSION: '20.x'
  ALIGNMENT_REPORT_PATH: 'alignment-reports'

jobs:
  detect-version-misalignment:
    name: Detect Version Misalignment
    runs-on: ubuntu-latest
    outputs:
      misalignment-detected: ${{ steps.detect.outputs.misalignment-detected }}
      misalignment-report: ${{ steps.detect.outputs.misalignment-report }}
      alignment-complexity: ${{ steps.detect.outputs.alignment-complexity }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install analysis tools
        run: |
          npm install -g syncpack@latest
          npm install -g npm-check-updates@latest
          npm install -g semver@latest

      - name: Detect version misalignments
        id: detect
        run: |
          echo "Detecting version misalignments across workspaces..."
          
          mkdir -p ${{ env.ALIGNMENT_REPORT_PATH }}
          
          cat > detect-misalignment.js << 'EOF'
          const fs = require('fs');
          const path = require('path');
          const semver = require('semver');
          
          const workspaces = ['frontend', 'backend', 'shared'];
          const report = {
            timestamp: new Date().toISOString(),
            misalignments: [],
            severity_counts: { critical: 0, major: 0, minor: 0 },
            recommendations: [],
            complexity_score: 0
          };
          
          // Collect all dependencies from all workspaces
          const dependencies = {};
          const workspaceData = {};
          
          workspaces.forEach(workspace => {
            const packagePath = path.join(workspace, 'package.json');
            if (fs.existsSync(packagePath)) {
              const pkg = JSON.parse(fs.readFileSync(packagePath, 'utf8'));
              workspaceData[workspace] = pkg;
              
              // Collect all dependency types
              ['dependencies', 'devDependencies', 'peerDependencies'].forEach(depType => {
                if (pkg[depType]) {
                  Object.entries(pkg[depType]).forEach(([name, version]) => {
                    if (!dependencies[name]) {
                      dependencies[name] = {};
                    }
                    if (!dependencies[name][depType]) {
                      dependencies[name][depType] = {};
                    }
                    dependencies[name][depType][workspace] = version;
                  });
                }
              });
            }
          });
          
          // Analyze misalignments
          Object.entries(dependencies).forEach(([depName, depTypes]) => {
            Object.entries(depTypes).forEach(([depType, workspaceVersions]) => {
              const versions = Object.values(workspaceVersions);
              const uniqueVersions = [...new Set(versions)];
              
              if (uniqueVersions.length > 1) {
                // Determine severity
                let severity = 'minor';
                const cleanVersions = uniqueVersions.map(v => v.replace(/^[\^~]/, ''));
                
                try {
                  const sortedVersions = cleanVersions.sort(semver.compare);
                  const lowestMajor = semver.major(sortedVersions[0]);
                  const highestMajor = semver.major(sortedVersions[sortedVersions.length - 1]);
                  
                  if (lowestMajor !== highestMajor) {
                    severity = 'critical';
                  } else {
                    const lowestMinor = semver.minor(sortedVersions[0]);
                    const highestMinor = semver.minor(sortedVersions[sortedVersions.length - 1]);
                    if (highestMinor - lowestMinor > 2) {
                      severity = 'major';
                    }
                  }
                } catch (error) {
                  // If semver parsing fails, treat as major issue
                  severity = 'major';
                }
                
                // Special cases for critical packages
                if (['typescript', 'react', 'vue', 'angular', 'express'].includes(depName)) {
                  if (severity === 'minor') severity = 'major';
                  if (severity === 'major') severity = 'critical';
                }
                
                report.misalignments.push({
                  package: depName,
                  type: depType,
                  versions: workspaceVersions,
                  unique_versions: uniqueVersions,
                  severity: severity,
                  complexity_factor: uniqueVersions.length * (severity === 'critical' ? 3 : severity === 'major' ? 2 : 1)
                });
                
                report.severity_counts[severity]++;
                report.complexity_score += uniqueVersions.length * (severity === 'critical' ? 3 : severity === 'major' ? 2 : 1);
              }
            });
          });
          
          // Generate recommendations
          if (report.misalignments.length === 0) {
            report.recommendations.push('All dependency versions are properly aligned');
          } else {
            if (report.severity_counts.critical > 0) {
              report.recommendations.push('URGENT: Critical version misalignments detected - major version differences found');
            }
            if (report.severity_counts.major > 5) {
              report.recommendations.push('High number of major misalignments - consider aggressive alignment strategy');
            }
            if (report.complexity_score > 20) {
              report.recommendations.push('High complexity alignment required - recommend manual review');
            }
            report.recommendations.push(`Total misalignments: ${report.misalignments.length}`);
          }
          
          // Save detailed report
          fs.writeFileSync('alignment-reports/misalignment-report.json', JSON.stringify(report, null, 2));
          
          // Generate human-readable report
          const readableReport = [];
          readableReport.push('# Version Misalignment Report\n');
          readableReport.push(`**Generated**: ${new Date(report.timestamp).toLocaleString()}\n`);
          readableReport.push(`**Total Misalignments**: ${report.misalignments.length}`);
          readableReport.push(`**Complexity Score**: ${report.complexity_score}/100\n`);
          
          readableReport.push('## Severity Breakdown');
          readableReport.push(`- ðŸ”´ Critical: ${report.severity_counts.critical}`);
          readableReport.push(`- ðŸŸ¡ Major: ${report.severity_counts.major}`);
          readableReport.push(`- ðŸŸ¢ Minor: ${report.severity_counts.minor}\n`);
          
          if (report.misalignments.length > 0) {
            readableReport.push('## Detected Misalignments\n');
            report.misalignments.forEach(mis => {
              const severityIcon = mis.severity === 'critical' ? 'ðŸ”´' : mis.severity === 'major' ? 'ðŸŸ¡' : 'ðŸŸ¢';
              readableReport.push(`### ${severityIcon} ${mis.package} (${mis.type})`);
              Object.entries(mis.versions).forEach(([workspace, version]) => {
                readableReport.push(`- **${workspace}**: ${version}`);
              });
              readableReport.push('');
            });
          }
          
          readableReport.push('## Recommendations');
          report.recommendations.forEach(rec => readableReport.push(`- ${rec}`));
          
          fs.writeFileSync('alignment-reports/misalignment-report.md', readableReport.join('\n'));
          
          console.log(`Misalignment detection complete:`);
          console.log(`- Total misalignments: ${report.misalignments.length}`);
          console.log(`- Critical: ${report.severity_counts.critical}, Major: ${report.severity_counts.major}, Minor: ${report.severity_counts.minor}`);
          console.log(`- Complexity score: ${report.complexity_score}`);
          EOF
          
          node detect-misalignment.js
          
          # Set outputs
          misalignment_count=$(cat alignment-reports/misalignment-report.json | jq '.misalignments | length')
          complexity_score=$(cat alignment-reports/misalignment-report.json | jq '.complexity_score')
          
          echo "misalignment-detected=$([[ $misalignment_count -gt 0 ]] && echo 'true' || echo 'false')" >> $GITHUB_OUTPUT
          echo "alignment-complexity=$complexity_score" >> $GITHUB_OUTPUT
          
          echo "misalignment-report<<EOF" >> $GITHUB_OUTPUT
          cat alignment-reports/misalignment-report.json >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Upload misalignment report
        uses: actions/upload-artifact@v4
        with:
          name: misalignment-report
          path: alignment-reports/
          retention-days: 30

  create-alignment-strategy:
    name: Create Alignment Strategy
    runs-on: ubuntu-latest
    needs: detect-version-misalignment
    if: needs.detect-version-misalignment.outputs.misalignment-detected == 'true'
    outputs:
      alignment-strategy: ${{ steps.strategy.outputs.alignment-strategy }}
      requires-manual-review: ${{ steps.strategy.outputs.requires-manual-review }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Download misalignment report
        uses: actions/download-artifact@v4
        with:
          name: misalignment-report
          path: alignment-reports/

      - name: Create alignment strategy
        id: strategy
        run: |
          echo "Creating alignment strategy..."
          
          cat > create-strategy.js << 'EOF'
          const fs = require('fs');
          const semver = require('semver');
          
          const report = JSON.parse(fs.readFileSync('alignment-reports/misalignment-report.json', 'utf8'));
          const inputStrategy = process.env.INPUT_STRATEGY || 'conservative';
          const targetVersion = process.env.TARGET_VERSION || '';
          const forceAlignment = process.env.FORCE_ALIGNMENT === 'true';
          
          const strategy = {
            name: inputStrategy,
            target_version: targetVersion,
            force_alignment: forceAlignment,
            actions: [],
            manual_review_required: false,
            estimated_risk: 'low',
            execution_plan: []
          };
          
          // Determine risk level
          if (report.severity_counts.critical > 0) {
            strategy.estimated_risk = 'high';
            strategy.manual_review_required = true;
          } else if (report.severity_counts.major > 3 || report.complexity_score > 15) {
            strategy.estimated_risk = 'medium';
          }
          
          // Create actions for each misalignment
          report.misalignments.forEach(misalignment => {
            const action = {
              package: misalignment.package,
              type: misalignment.type,
              current_versions: misalignment.versions,
              severity: misalignment.severity
            };
            
            // Determine target version based on strategy
            const versions = misalignment.unique_versions;
            let targetVersion;
            
            switch (inputStrategy) {
              case 'conservative':
                // Use most commonly used version or lowest safe version
                targetVersion = versions.sort()[0];
                action.rationale = 'Conservative approach - use lowest version for compatibility';
                break;
                
              case 'aggressive':
                // Use highest version
                const cleanVersions = versions.map(v => v.replace(/^[\^~]/, ''));
                try {
                  targetVersion = cleanVersions.sort(semver.rcompare)[0];
                  // Add range prefix back
                  targetVersion = versions.find(v => v.includes(targetVersion.split('.')[0])) || targetVersion;
                } catch {
                  targetVersion = versions.sort().pop();
                }
                action.rationale = 'Aggressive approach - use latest available version';
                break;
                
              case 'latest':
                // Always use latest from registry (would need npm API call)
                targetVersion = 'latest';
                action.rationale = 'Use latest version from npm registry';
                break;
                
              case 'specific':
                targetVersion = process.env.TARGET_VERSION || versions[0];
                action.rationale = 'Use specifically provided version';
                break;
            }
            
            action.target_version = targetVersion;
            
            // Determine if manual review is needed
            if (misalignment.severity === 'critical' && !forceAlignment) {
              action.manual_review_required = true;
              strategy.manual_review_required = true;
            }
            
            // Add to execution plan
            const workspacesToUpdate = Object.keys(misalignment.versions);
            workspacesToUpdate.forEach(workspace => {
              if (misalignment.versions[workspace] !== targetVersion) {
                strategy.execution_plan.push({
                  workspace: workspace,
                  package: misalignment.package,
                  dependency_type: misalignment.type,
                  from_version: misalignment.versions[workspace],
                  to_version: targetVersion,
                  action: 'update_version'
                });
              }
            });
            
            strategy.actions.push(action);
          });
          
          // Override manual review if force is enabled
          if (forceAlignment) {
            strategy.manual_review_required = false;
            strategy.actions.forEach(action => {
              action.manual_review_required = false;
            });
          }
          
          fs.writeFileSync('alignment-strategy.json', JSON.stringify(strategy, null, 2));
          
          console.log(`Alignment strategy created:`);
          console.log(`- Strategy: ${strategy.name}`);
          console.log(`- Actions: ${strategy.actions.length}`);
          console.log(`- Execution steps: ${strategy.execution_plan.length}`);
          console.log(`- Manual review required: ${strategy.manual_review_required}`);
          console.log(`- Estimated risk: ${strategy.estimated_risk}`);
          EOF
          
          INPUT_STRATEGY="${{ github.event.inputs.strategy || 'conservative' }}" \
          TARGET_VERSION="${{ github.event.inputs.target_version }}" \
          FORCE_ALIGNMENT="${{ github.event.inputs.force_alignment }}" \
          node create-strategy.js
          
          # Set outputs
          echo "alignment-strategy<<EOF" >> $GITHUB_OUTPUT
          cat alignment-strategy.json >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          
          manual_review=$(cat alignment-strategy.json | jq -r '.manual_review_required')
          echo "requires-manual-review=$manual_review" >> $GITHUB_OUTPUT

      - name: Upload alignment strategy
        uses: actions/upload-artifact@v4
        with:
          name: alignment-strategy
          path: alignment-strategy.json

  execute-version-alignment:
    name: Execute Version Alignment
    runs-on: ubuntu-latest
    needs: [detect-version-misalignment, create-alignment-strategy]
    if: needs.create-alignment-strategy.outputs.requires-manual-review == 'false'
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Configure Git
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"

      - name: Download alignment strategy
        uses: actions/download-artifact@v4
        with:
          name: alignment-strategy

      - name: Install alignment tools
        run: |
          npm install -g syncpack@latest
          npm install -g npm-check-updates@latest

      - name: Execute version alignment
        run: |
          echo "Executing version alignment..."
          
          cat > execute-alignment.js << 'EOF'
          const fs = require('fs');
          const { execSync } = require('child_process');
          
          const strategy = JSON.parse(fs.readFileSync('alignment-strategy.json', 'utf8'));
          
          const results = {
            timestamp: new Date().toISOString(),
            strategy_used: strategy.name,
            executed_actions: [],
            failed_actions: [],
            workspace_changes: {}
          };
          
          console.log(`Executing ${strategy.execution_plan.length} alignment actions...`);
          
          // Group actions by workspace for efficient execution
          const workspaceActions = {};
          strategy.execution_plan.forEach(action => {
            if (!workspaceActions[action.workspace]) {
              workspaceActions[action.workspace] = [];
            }
            workspaceActions[action.workspace].push(action);
          });
          
          // Execute actions for each workspace
          Object.entries(workspaceActions).forEach(([workspace, actions]) => {
            console.log(`Processing ${actions.length} actions for ${workspace}...`);
            results.workspace_changes[workspace] = [];
            
            actions.forEach(action => {
              try {
                const packagePath = `${workspace}/package.json`;
                if (fs.existsSync(packagePath)) {
                  const pkg = JSON.parse(fs.readFileSync(packagePath, 'utf8'));
                  
                  // Update the specific dependency
                  const depType = action.dependency_type;
                  if (pkg[depType] && pkg[depType][action.package]) {
                    const oldVersion = pkg[depType][action.package];
                    pkg[depType][action.package] = action.to_version;
                    
                    // Write updated package.json
                    fs.writeFileSync(packagePath, JSON.stringify(pkg, null, 2) + '\n');
                    
                    results.executed_actions.push(action);
                    results.workspace_changes[workspace].push({
                      package: action.package,
                      dependency_type: depType,
                      old_version: oldVersion,
                      new_version: action.to_version
                    });
                    
                    console.log(`âœ… Updated ${action.package} in ${workspace}: ${oldVersion} â†’ ${action.to_version}`);
                  }
                }
              } catch (error) {
                console.error(`âŒ Failed to update ${action.package} in ${workspace}:`, error.message);
                results.failed_actions.push({
                  ...action,
                  error: error.message
                });
              }
            });
          });
          
          // Regenerate lockfiles
          console.log('Regenerating lockfiles...');
          try {
            execSync('rm -f package-lock.json */package-lock.json', { stdio: 'inherit' });
            execSync('npm install', { stdio: 'inherit' });
            results.lockfile_regenerated = true;
          } catch (error) {
            console.error('Failed to regenerate lockfiles:', error.message);
            results.lockfile_regenerated = false;
            results.lockfile_error = error.message;
          }
          
          fs.writeFileSync('alignment-results.json', JSON.stringify(results, null, 2));
          
          console.log(`Alignment execution complete:`);
          console.log(`- Successful actions: ${results.executed_actions.length}`);
          console.log(`- Failed actions: ${results.failed_actions.length}`);
          console.log(`- Workspaces modified: ${Object.keys(results.workspace_changes).length}`);
          EOF
          
          node execute-alignment.js

      - name: Validate alignment results
        run: |
          echo "Validating alignment results..."
          
          # Run syncpack to verify no more misalignments
          if command -v syncpack &> /dev/null; then
            echo "Running syncpack lint to verify alignment..."
            if syncpack lint; then
              echo "âœ… All packages are now properly aligned"
            else
              echo "âš ï¸ Some misalignments may still exist"
              syncpack list-mismatches || true
            fi
          fi
          
          # Test builds
          echo "Testing builds after alignment..."
          
          # Build shared first
          if npm run build:shared; then
            echo "âœ… Shared package builds successfully"
          else
            echo "âŒ Shared package build failed after alignment"
            exit 1
          fi
          
          # Test other workspaces
          for workspace in frontend backend; do
            echo "Testing build for $workspace..."
            if npm run build --workspace=$workspace --if-present; then
              echo "âœ… $workspace builds successfully"
            else
              echo "âŒ $workspace build failed after alignment"
              # Don't exit here, collect all failures
            fi
          done

      - name: Create alignment summary
        run: |
          cat > alignment-summary.md << 'EOF'
          # Version Alignment Summary
          
          This automated version alignment was performed by the version-alignment workflow.
          
          ## Alignment Strategy
          - **Strategy**: ${{ github.event.inputs.strategy || 'conservative' }}
          - **Force Alignment**: ${{ github.event.inputs.force_alignment || 'false' }}
          - **Target Version**: ${{ github.event.inputs.target_version || 'auto-determined' }}
          
          ## Execution Results
          EOF
          
          if [ -f "alignment-results.json" ]; then
            echo "### Actions Executed" >> alignment-summary.md
            echo '```json' >> alignment-summary.md
            cat alignment-results.json | jq '.executed_actions' >> alignment-summary.md
            echo '```' >> alignment-summary.md
            echo "" >> alignment-summary.md
            
            echo "### Workspace Changes" >> alignment-summary.md
            echo '```json' >> alignment-summary.md
            cat alignment-results.json | jq '.workspace_changes' >> alignment-summary.md
            echo '```' >> alignment-summary.md
            echo "" >> alignment-summary.md
            
            if [ "$(cat alignment-results.json | jq '.failed_actions | length')" -gt 0 ]; then
              echo "### Failed Actions" >> alignment-summary.md
              echo '```json' >> alignment-summary.md
              cat alignment-results.json | jq '.failed_actions' >> alignment-summary.md
              echo '```' >> alignment-summary.md
              echo "" >> alignment-summary.md
            fi
          fi
          
          cat >> alignment-summary.md << 'EOF'
          
          ## Post-Alignment Validation
          - âœ… Lockfiles regenerated
          - âœ… Package builds validated
          - âœ… Version consistency verified
          
          ## Impact Assessment
          This alignment resolves version misalignments that could lead to:
          - Dependency conflicts during installation
          - Runtime errors due to incompatible versions
          - Development environment inconsistencies
          - CI/CD pipeline failures
          
          ## Next Steps
          1. Review the changes in this commit
          2. Run comprehensive tests locally
          3. Monitor for any compatibility issues
          4. Update documentation if API changes occurred
          
          ---
          ðŸ¤– Automated by version-alignment workflow
          EOF

      - name: Commit alignment changes
        run: |
          if git diff --exit-code; then
            echo "No changes to commit"
            exit 0
          fi
          
          # Add all changes
          git add .
          
          # Create commit message
          strategy="${{ github.event.inputs.strategy || 'conservative' }}"
          
          git commit -m "chore: align dependency versions using $strategy strategy

          - Resolved version misalignments across workspaces
          - Applied $strategy alignment strategy for compatibility
          - Regenerated lockfiles for consistency
          - Validated builds after alignment
          
          Auto-generated by version-alignment workflow"

      - name: Upload alignment results
        uses: actions/upload-artifact@v4
        with:
          name: alignment-results
          path: |
            alignment-results.json
            alignment-summary.md

  manual-review-notification:
    name: Manual Review Required
    runs-on: ubuntu-latest
    needs: [detect-version-misalignment, create-alignment-strategy]
    if: needs.create-alignment-strategy.outputs.requires-manual-review == 'true'
    steps:
      - name: Create manual review issue
        uses: actions/github-script@v7
        with:
          script: |
            const strategy = JSON.parse(`${{ needs.create-alignment-strategy.outputs.alignment-strategy }}`);
            const criticalMisalignments = strategy.actions.filter(a => a.severity === 'critical');
            
            const issueBody = `
            # ðŸ”´ Manual Review Required: Critical Version Misalignments Detected
            
            The version alignment workflow has detected critical dependency version misalignments that require manual review before automated resolution.
            
            ## Critical Issues Detected
            ${criticalMisalignments.map(action => 
              `### ${action.package} (${action.type})
              - **Severity**: ${action.severity}
              - **Current Versions**: 
              ${Object.entries(action.current_versions).map(([ws, ver]) => `  - ${ws}: ${ver}`).join('\n')}
              - **Proposed Target**: ${action.target_version}
              - **Rationale**: ${action.rationale}`
            ).join('\n\n')}
            
            ## Recommended Actions
            1. Review the critical misalignments above
            2. Verify compatibility of proposed version changes
            3. Check for breaking changes in dependency updates
            4. Consider running tests locally with proposed changes
            5. Re-run the workflow with \`force_alignment: true\` if safe to proceed
            
            ## Workflow Configuration
            - **Strategy**: ${strategy.name}
            - **Estimated Risk**: ${strategy.estimated_risk}
            - **Total Actions**: ${strategy.actions.length}
            - **Manual Review Required**: ${strategy.manual_review_required}
            
            ## Next Steps
            To proceed with automatic alignment despite the risks:
            1. Go to [Actions > Version Alignment](../../actions/workflows/version-alignment.yml)
            2. Click "Run workflow"
            3. Set \`force_alignment\` to \`true\`
            4. Choose appropriate strategy (conservative/aggressive/latest)
            
            ---
            ðŸ¤– Generated by version-alignment workflow
            `;
            
            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: 'ðŸ”´ Manual Review Required: Critical Version Misalignments',
              body: issueBody,
              labels: ['dependencies', 'manual-review', 'critical']
            });

      - name: Generate manual review summary
        run: |
          echo "## Manual Review Required" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "ðŸ”´ **Critical version misalignments detected**" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "The workflow has detected version misalignments that require manual review due to:" >> $GITHUB_STEP_SUMMARY
          echo "- Critical severity level dependencies" >> $GITHUB_STEP_SUMMARY
          echo "- Potential breaking changes" >> $GITHUB_STEP_SUMMARY
          echo "- High complexity alignment required" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Next Steps:**" >> $GITHUB_STEP_SUMMARY
          echo "1. Review the created GitHub issue for details" >> $GITHUB_STEP_SUMMARY
          echo "2. Verify compatibility manually" >> $GITHUB_STEP_SUMMARY
          echo "3. Re-run workflow with force_alignment if safe" >> $GITHUB_STEP_SUMMARY

  workflow-summary:
    name: Workflow Summary
    runs-on: ubuntu-latest
    needs: [detect-version-misalignment, create-alignment-strategy, execute-version-alignment, manual-review-notification]
    if: always()
    steps:
      - name: Generate comprehensive summary
        run: |
          echo "## Version Alignment Workflow Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # Detection results
          if [ "${{ needs.detect-version-misalignment.result }}" = "success" ]; then
            echo "âœ… **Misalignment Detection**: Completed" >> $GITHUB_STEP_SUMMARY
            echo "   - Misalignments found: ${{ needs.detect-version-misalignment.outputs.misalignment-detected }}" >> $GITHUB_STEP_SUMMARY
            echo "   - Complexity score: ${{ needs.detect-version-misalignment.outputs.alignment-complexity }}" >> $GITHUB_STEP_SUMMARY
          else
            echo "âŒ **Misalignment Detection**: Failed" >> $GITHUB_STEP_SUMMARY
          fi
          
          # Strategy creation
          if [ "${{ needs.create-alignment-strategy.result }}" = "success" ]; then
            echo "âœ… **Strategy Creation**: Completed" >> $GITHUB_STEP_SUMMARY
            echo "   - Manual review required: ${{ needs.create-alignment-strategy.outputs.requires-manual-review }}" >> $GITHUB_STEP_SUMMARY
          elif [ "${{ needs.create-alignment-strategy.result }}" = "skipped" ]; then
            echo "â­ï¸ **Strategy Creation**: Skipped (no misalignments)" >> $GITHUB_STEP_SUMMARY
          else
            echo "âŒ **Strategy Creation**: Failed" >> $GITHUB_STEP_SUMMARY
          fi
          
          # Execution results
          if [ "${{ needs.execute-version-alignment.result }}" = "success" ]; then
            echo "âœ… **Version Alignment**: Executed successfully" >> $GITHUB_STEP_SUMMARY
          elif [ "${{ needs.execute-version-alignment.result }}" = "skipped" ]; then
            echo "â­ï¸ **Version Alignment**: Skipped (manual review required)" >> $GITHUB_STEP_SUMMARY
          else
            echo "âŒ **Version Alignment**: Failed" >> $GITHUB_STEP_SUMMARY
          fi
          
          # Manual review notification
          if [ "${{ needs.manual-review-notification.result }}" = "success" ]; then
            echo "ðŸ“‹ **Manual Review**: Issue created for review" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Workflow Configuration" >> $GITHUB_STEP_SUMMARY
          echo "- **Strategy**: ${{ github.event.inputs.strategy || 'conservative' }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Target Version**: ${{ github.event.inputs.target_version || 'auto-determined' }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Force Alignment**: ${{ github.event.inputs.force_alignment || 'false' }}" >> $GITHUB_STEP_SUMMARY