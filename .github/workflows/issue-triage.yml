name: Issue Triage & Management

on:
  issues:
    types: [opened, edited, labeled, unlabeled, assigned, unassigned]
  issue_comment:
    types: [created, edited]
  schedule:
    - cron: '0 9 * * 1'  # Every Monday at 9 AM UTC

permissions:
  issues: write
  pull-requests: read

jobs:
  auto-triage:
    name: Auto-triage New Issues
    runs-on: ubuntu-latest
    if: github.event_name == 'issues' && github.event.action == 'opened'
    
    steps:
      - name: Analyze and triage issue
        uses: actions/github-script@v7
        with:
          script: |
            const issue = context.payload.issue;
            const title = issue.title.toLowerCase();
            const body = (issue.body || '').toLowerCase();
            
            // Priority assignment based on keywords
            let priority = 'medium';
            let severity = '';
            
            // High priority keywords
            if (title.includes('critical') || title.includes('urgent') || title.includes('security') ||
                body.includes('production down') || body.includes('data loss') || body.includes('security vulnerability')) {
              priority = 'high';
              severity = 'critical';
            }
            
            // Low priority keywords
            if (title.includes('minor') || title.includes('cosmetic') || title.includes('documentation') ||
                body.includes('nice to have') || body.includes('enhancement') || body.includes('documentation')) {
              priority = 'low';
            }
            
            // Assign priority label
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issue.number,
              labels: [`priority/${priority}`]
            });
            
            // Assign severity for bugs
            if (severity && issue.labels.some(label => label.name === 'bug')) {
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                labels: [`severity/${severity}`]
              });
            }
            
            // Auto-assign based on component
            let assignees = [];
            
            if (body.includes('backend') || body.includes('api') || body.includes('database')) {
              // Add backend team members when available
              assignees.push('backend-lead');  // Replace with actual usernames
            }
            
            if (body.includes('frontend') || body.includes('ui') || body.includes('react')) {
              // Add frontend team members when available
              assignees.push('frontend-lead');  // Replace with actual usernames
            }
            
            if (assignees.length > 0) {
              try {
                await github.rest.issues.addAssignees({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  assignees: assignees
                });
              } catch (error) {
                console.log('Could not assign users, they may not have access');
              }
            }
            
            // Add to project board if it exists
            try {
              // This would require project board API integration
              console.log('Would add to project board if configured');
            } catch (error) {
              console.log('Project board not configured');
            }

  validate-issue:
    name: Validate Issue Template
    runs-on: ubuntu-latest
    if: github.event_name == 'issues' && github.event.action == 'opened'
    
    steps:
      - name: Check issue template compliance
        uses: actions/github-script@v7
        with:
          script: |
            const issue = context.payload.issue;
            const body = issue.body || '';
            
            let missingFields = [];
            let suggestions = [];
            
            // Check for bug report template compliance
            if (issue.labels.some(label => label.name === 'bug')) {
              if (!body.includes('## Steps to Reproduce')) {
                missingFields.push('Steps to Reproduce');
              }
              if (!body.includes('## Expected Behavior')) {
                missingFields.push('Expected Behavior');
              }
              if (!body.includes('## Environment')) {
                missingFields.push('Environment information');
              }
            }
            
            // Check for feature request template compliance
            if (issue.labels.some(label => label.name === 'enhancement')) {
              if (!body.includes('## Problem Statement')) {
                missingFields.push('Problem Statement');
              }
              if (!body.includes('## Proposed Solution')) {
                missingFields.push('Proposed Solution');
              }
              if (!body.includes('## Use Cases')) {
                missingFields.push('Use Cases');
              }
            }
            
            // Check for minimal description
            if (body.length < 50) {
              suggestions.push('Please provide a more detailed description');
            }
            
            // Create comment if issues found
            if (missingFields.length > 0 || suggestions.length > 0) {
              let comment = '👋 Thank you for opening this issue!\n\n';
              
              if (missingFields.length > 0) {
                comment += '⚠️ **Missing Information:**\n';
                comment += 'To help us process this issue faster, please provide:\n';
                missingFields.forEach(field => {
                  comment += `- ${field}\n`;
                });
                comment += '\n';
              }
              
              if (suggestions.length > 0) {
                comment += '💡 **Suggestions:**\n';
                suggestions.forEach(suggestion => {
                  comment += `- ${suggestion}\n`;
                });
                comment += '\n';
              }
              
              comment += 'You can edit your issue description to add the missing information.';
              
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                body: comment
              });
              
              // Add needs-info label
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                labels: ['needs-info']
              });
            }

  manage-issue-lifecycle:
    name: Manage Issue Lifecycle
    runs-on: ubuntu-latest
    if: github.event_name == 'issues' || github.event_name == 'issue_comment'
    
    steps:
      - name: Update issue status based on activity
        uses: actions/github-script@v7
        with:
          script: |
            const issue = context.payload.issue;
            
            // Remove needs-info label if user responded
            if (context.event_name === 'issue_comment' && 
                context.payload.comment.user.login === issue.user.login) {
              
              try {
                await github.rest.issues.removeLabel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  name: 'needs-info'
                });
                
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  labels: ['needs-review']
                });
              } catch (error) {
                // Labels might not exist, that's okay
              }
            }
            
            // Auto-assign to project columns based on labels
            const labels = issue.labels.map(label => label.name);
            
            if (labels.includes('bug') && labels.includes('priority/high')) {
              // Add to urgent column
              console.log('Would move to urgent column');
            } else if (labels.includes('enhancement')) {
              // Add to feature backlog
              console.log('Would move to feature backlog');
            }

  weekly-issue-report:
    name: Weekly Issue Report
    runs-on: ubuntu-latest
    if: github.event_name == 'schedule'
    
    steps:
      - name: Generate weekly issue report
        uses: actions/github-script@v7
        with:
          script: |
            const oneWeekAgo = new Date();
            oneWeekAgo.setDate(oneWeekAgo.getDate() - 7);
            
            // Get issues from the last week
            const { data: issues } = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'all',
              since: oneWeekAgo.toISOString(),
              per_page: 100
            });
            
            // Filter and categorize
            const newIssues = issues.filter(issue => 
              !issue.pull_request && 
              new Date(issue.created_at) >= oneWeekAgo
            );
            
            const closedIssues = issues.filter(issue => 
              !issue.pull_request && 
              issue.state === 'closed' &&
              new Date(issue.closed_at) >= oneWeekAgo
            );
            
            const bugCount = newIssues.filter(issue => 
              issue.labels.some(label => label.name === 'bug')
            ).length;
            
            const enhancementCount = newIssues.filter(issue => 
              issue.labels.some(label => label.name === 'enhancement')
            ).length;
            
            // Generate report
            let report = '# 📊 Weekly Issue Report\n\n';
            report += `**Period:** ${oneWeekAgo.toISOString().split('T')[0]} to ${new Date().toISOString().split('T')[0]}\n\n`;
            report += `## Summary\n`;
            report += `- 🆕 New Issues: ${newIssues.length}\n`;
            report += `- ✅ Closed Issues: ${closedIssues.length}\n`;
            report += `- 🐛 Bugs Reported: ${bugCount}\n`;
            report += `- ✨ Enhancement Requests: ${enhancementCount}\n\n`;
            
            if (newIssues.length > 0) {
              report += `## New Issues\n`;
              newIssues.slice(0, 10).forEach(issue => {
                report += `- [#${issue.number}](${issue.html_url}) ${issue.title}\n`;
              });
              
              if (newIssues.length > 10) {
                report += `- ... and ${newIssues.length - 10} more\n`;
              }
              report += '\n';
            }
            
            if (closedIssues.length > 0) {
              report += `## Closed Issues\n`;
              closedIssues.slice(0, 10).forEach(issue => {
                report += `- [#${issue.number}](${issue.html_url}) ${issue.title}\n`;
              });
              
              if (closedIssues.length > 10) {
                report += `- ... and ${closedIssues.length - 10} more\n`;
              }
            }
            
            console.log(report);
            
            // Optionally create an issue with the report
            // await github.rest.issues.create({
            //   owner: context.repo.owner,
            //   repo: context.repo.repo,
            //   title: `Weekly Issue Report - ${new Date().toISOString().split('T')[0]}`,
            //   body: report,
            //   labels: ['report', 'internal']
            // });

  close-resolved-issues:
    name: Close Resolved Issues
    runs-on: ubuntu-latest
    if: github.event_name == 'issue_comment'
    
    steps:
      - name: Check for resolution keywords
        uses: actions/github-script@v7
        with:
          script: |
            const comment = context.payload.comment.body.toLowerCase();
            const commenter = context.payload.comment.user.login;
            const issue = context.payload.issue;
            
            // Check if it's the issue author or a maintainer
            const { data: collaborator } = await github.rest.repos.getCollaboratorPermissionLevel({
              owner: context.repo.owner,
              repo: context.repo.repo,
              username: commenter
            }).catch(() => ({ data: { permission: 'none' } }));
            
            const canClose = commenter === issue.user.login || 
                           ['admin', 'write'].includes(collaborator.permission);
            
            // Resolution keywords
            const resolutionKeywords = [
              'this is resolved',
              'this is fixed',
              'working now',
              'solved',
              'close this',
              'closing this'
            ];
            
            const shouldClose = resolutionKeywords.some(keyword => 
              comment.includes(keyword)
            );
            
            if (canClose && shouldClose && issue.state === 'open') {
              await github.rest.issues.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                state: 'closed'
              });
              
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                body: '✅ Issue automatically closed based on resolution comment.'
              });
            }