name: Multi-Package Sync Coordinator v2
# Enhanced synchronization and version alignment for multi-package repositories
# Provides intelligent package dependency management, version alignment, and automated PR creation

on:
  push:
    branches: [ main, development, test, dev ]
    paths:
      - '**/package.json'
      - '**/package-lock.json'
      - '.github/workflows/sync-coordinator-v2.yml'
  pull_request:
    branches: [ main, development, test ]
    paths:
      - '**/package.json'
      - '**/package-lock.json'
  schedule:
    - cron: '0 4 * * MON'  # Weekly on Monday at 4 AM UTC
  workflow_dispatch:
    inputs:
      sync_mode:
        description: 'Synchronization mode'
        required: true
        default: 'align'
        type: choice
        options:
          - align          # Smart alignment of versions across packages
          - force-sync     # Force synchronization ignoring conflicts
          - validate-only  # Only validate without changes
          - update-deps    # Update dependencies to latest compatible versions
          - security-only  # Only update security-related dependencies
      target_packages:
        description: 'Target packages (comma-separated, "all", or "changed")'
        required: false
        default: 'changed'
      auto_create_pr:
        description: 'Automatically create PR for changes'
        required: false
        default: true
        type: boolean
      dependency_strategy:
        description: 'Dependency update strategy'
        required: false
        default: 'conservative'
        type: choice
        options:
          - conservative  # Only patch and minor updates
          - moderate      # Include compatible major updates
          - aggressive    # Update to latest versions
      notification_level:
        description: 'Notification level'
        required: false
        default: 'normal'
        type: choice
        options:
          - silent
          - normal
          - verbose

env:
  NODE_VERSION: '20'
  CACHE_KEY_SUFFIX: v2
  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
  SYNC_BRANCH_PREFIX: 'sync-coordinator'

permissions:
  contents: write
  pull-requests: write
  checks: write
  actions: read
  security-events: write

jobs:
  # Initialize sync coordinator with enhanced package detection
  sync-initialization:
    name: Initialize Sync Coordinator
    runs-on: ubuntu-latest
    outputs:
      packages-matrix: ${{ steps.package-discovery.outputs.packages }}
      sync-id: ${{ steps.sync-metadata.outputs.sync-id }}
      changed-packages: ${{ steps.changes.outputs.packages }}
      dependency-graph: ${{ steps.dependency-analysis.outputs.graph }}
      sync-strategy: ${{ steps.strategy.outputs.strategy }}
      requires-sync: ${{ steps.sync-check.outputs.requires-sync }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Generate sync metadata
        id: sync-metadata
        run: |
          sync_id="sync-$(date +%Y%m%d-%H%M%S)-$(echo ${{ github.sha }} | cut -c1-8)"
          echo "sync-id=$sync_id" >> $GITHUB_OUTPUT
          echo "timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)" >> $GITHUB_OUTPUT
          echo "branch=${{ github.ref_name }}" >> $GITHUB_OUTPUT
          echo "trigger=${{ github.event_name }}" >> $GITHUB_OUTPUT

      - name: Discover packages and workspaces
        id: package-discovery
        run: |
          packages=()
          
          # Discover workspaces from root package.json
          if [[ -f "package.json" ]]; then
            workspaces=$(jq -r '.workspaces[]? // empty' package.json 2>/dev/null || echo "")
            if [[ -n "$workspaces" ]]; then
              for workspace in $workspaces; do
                if [[ -d "$workspace" && -f "$workspace/package.json" ]]; then
                  packages+=("$workspace")
                fi
              done
            fi
          fi
          
          # Manual discovery of common package directories
          for dir in backend frontend shared api web client server common lib packages/*; do
            if [[ -d "$dir" && -f "$dir/package.json" ]]; then
              if [[ ! " ${packages[@]} " =~ " $dir " ]]; then
                packages+=("$dir")
              fi
            fi
          done
          
          # Add root if it has package.json and is not a monorepo
          if [[ -f "package.json" && ${#packages[@]} -eq 0 ]]; then
            packages+=(".")
          fi
          
          if [[ ${#packages[@]} -eq 0 ]]; then
            echo "❌ No packages found in repository"
            packages=(".")
          fi
          
          # Convert to JSON matrix
          matrix_json=$(printf '%s\n' "${packages[@]}" | jq -R . | jq -s .)
          echo "packages=$matrix_json" >> $GITHUB_OUTPUT
          
          echo "📦 Discovered packages:"
          printf '%s\n' "${packages[@]}" | sed 's/^/  - /'

      - name: Detect changed packages
        uses: dorny/paths-filter@v3
        id: changes
        with:
          list-files: json
          filters: |
            packages:
              - '**/package.json'
              - '**/package-lock.json'
              - 'package.json'
              - 'package-lock.json'
            backend:
              - 'backend/**'
            frontend:
              - 'frontend/**'
            shared:
              - 'shared/**'
            workflows:
              - '.github/workflows/**'

      - name: Analyze dependency graph
        id: dependency-analysis
        run: |
          echo "🔍 Analyzing dependency relationships..."
          
          # Create dependency graph analysis
          graph_data="{}"
          packages_json='${{ steps.package-discovery.outputs.packages }}'
          
          echo "$packages_json" | jq -r '.[]' | while IFS= read -r package; do
            if [[ -f "$package/package.json" ]]; then
              name=$(jq -r '.name // "unknown"' "$package/package.json")
              version=$(jq -r '.version // "0.0.0"' "$package/package.json")
              deps=$(jq -r '.dependencies // {} | keys | join(",")' "$package/package.json")
              dev_deps=$(jq -r '.devDependencies // {} | keys | join(",")' "$package/package.json")
              
              echo "  📦 $name@$version (deps: ${deps//,/ })"
            fi
          done
          
          echo "graph={\"analyzed\": true, \"timestamp\": \"$(date -u +%Y-%m-%dT%H:%M:%SZ)\"}" >> $GITHUB_OUTPUT

      - name: Determine sync strategy
        id: strategy
        run: |
          strategy="${{ github.event.inputs.sync_mode || 'align' }}"
          target="${{ github.event.inputs.target_packages || 'changed' }}"
          
          case "$target" in
            "changed")
              if [[ "${{ steps.changes.outputs.packages }}" == "true" ]]; then
                strategy="align"
              else
                strategy="validate-only"
              fi
              ;;
            "all")
              strategy="${{ github.event.inputs.sync_mode || 'align' }}"
              ;;
          esac
          
          echo "strategy=$strategy" >> $GITHUB_OUTPUT
          echo "🎯 Sync strategy: $strategy"

      - name: Check if sync is required
        id: sync-check
        run: |
          requires_sync="false"
          
          if [[ "${{ steps.changes.outputs.packages }}" == "true" ]]; then
            requires_sync="true"
            echo "✅ Package changes detected, sync required"
          elif [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            requires_sync="true"
            echo "✅ Manual trigger, sync required"
          elif [[ "${{ github.event_name }}" == "schedule" ]]; then
            requires_sync="true"
            echo "✅ Scheduled sync, checking for updates"
          else
            echo "ℹ️ No sync required"
          fi
          
          echo "requires-sync=$requires_sync" >> $GITHUB_OUTPUT

  # Enhanced version alignment with conflict resolution
  version-alignment-analysis:
    name: Version Alignment Analysis
    runs-on: ubuntu-latest
    needs: sync-initialization
    if: needs.sync-initialization.outputs.requires-sync == 'true'
    strategy:
      matrix:
        package: ${{ fromJSON(needs.sync-initialization.outputs.packages-matrix) }}
      fail-fast: false
    outputs:
      alignment-status: ${{ steps.alignment-check.outputs.status }}
      conflicts-detected: ${{ steps.conflict-detection.outputs.conflicts }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          registry-url: 'https://registry.npmjs.org'

      - name: Validate package structure
        id: package-validation
        run: |
          package="${{ matrix.package }}"
          
          if [[ ! -f "$package/package.json" ]]; then
            echo "❌ Package.json not found in $package"
            echo "valid=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Validate JSON syntax
          if ! jq empty "$package/package.json" 2>/dev/null; then
            echo "❌ Invalid JSON in $package/package.json"
            echo "valid=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          echo "✅ Package $package is valid"
          echo "valid=true" >> $GITHUB_OUTPUT

      - name: Extract and analyze package metadata
        if: steps.package-validation.outputs.valid == 'true'
        id: package-metadata
        run: |
          package="${{ matrix.package }}"
          
          name=$(jq -r '.name // "unknown"' "$package/package.json")
          version=$(jq -r '.version // "0.0.0"' "$package/package.json")
          private=$(jq -r '.private // false' "$package/package.json")
          
          # Extract dependencies with versions
          deps=$(jq -r '.dependencies // {} | to_entries[] | "\(.key)@\(.value)"' "$package/package.json" | head -20)
          dev_deps_count=$(jq -r '.devDependencies // {} | length' "$package/package.json")
          peer_deps_count=$(jq -r '.peerDependencies // {} | length' "$package/package.json")
          
          echo "name=$name" >> $GITHUB_OUTPUT
          echo "version=$version" >> $GITHUB_OUTPUT
          echo "private=$private" >> $GITHUB_OUTPUT
          echo "deps-count=$(echo "$deps" | wc -l)" >> $GITHUB_OUTPUT
          echo "dev-deps-count=$dev_deps_count" >> $GITHUB_OUTPUT
          echo "peer-deps-count=$peer_deps_count" >> $GITHUB_OUTPUT
          
          echo "📦 Package: $name@$version (private: $private)"
          echo "   Dependencies: $(echo "$deps" | wc -l), DevDeps: $dev_deps_count, PeerDeps: $peer_deps_count"

      - name: Check for outdated dependencies
        if: steps.package-validation.outputs.valid == 'true'
        id: outdated-check
        continue-on-error: true
        run: |
          package="${{ matrix.package }}"
          cd "$package"
          
          if [[ -f "package-lock.json" ]]; then
            npm ci --silent || npm install --silent
          else
            npm install --silent
          fi
          
          # Check for outdated packages
          outdated_output=$(npm outdated --json 2>/dev/null || echo "{}")
          outdated_count=$(echo "$outdated_output" | jq 'length // 0')
          
          echo "outdated-count=$outdated_count" >> $GITHUB_OUTPUT
          echo "outdated-data=$outdated_output" >> $GITHUB_OUTPUT
          
          if [[ $outdated_count -gt 0 ]]; then
            echo "⚠️ Found $outdated_count outdated dependencies in $package"
          else
            echo "✅ All dependencies up to date in $package"
          fi

      - name: Security audit
        if: steps.package-validation.outputs.valid == 'true'
        id: security-audit
        continue-on-error: true
        run: |
          package="${{ matrix.package }}"
          cd "$package"
          
          # Run security audit
          audit_output=$(npm audit --json 2>/dev/null || echo '{"vulnerabilities": {}}')
          vuln_count=$(echo "$audit_output" | jq '.metadata.vulnerabilities.total // 0')
          critical_count=$(echo "$audit_output" | jq '.metadata.vulnerabilities.critical // 0')
          high_count=$(echo "$audit_output" | jq '.metadata.vulnerabilities.high // 0')
          
          echo "vulnerabilities=$vuln_count" >> $GITHUB_OUTPUT
          echo "critical=$critical_count" >> $GITHUB_OUTPUT
          echo "high=$high_count" >> $GITHUB_OUTPUT
          
          if [[ $critical_count -gt 0 || $high_count -gt 0 ]]; then
            echo "🚨 Found $critical_count critical and $high_count high vulnerabilities in $package"
          elif [[ $vuln_count -gt 0 ]]; then
            echo "⚠️ Found $vuln_count vulnerabilities in $package"
          else
            echo "✅ No vulnerabilities found in $package"
          fi

      - name: Generate alignment report
        id: alignment-check
        run: |
          package="${{ matrix.package }}"
          timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)
          
          mkdir -p reports/alignment
          
          # Create detailed alignment report
          cat > "reports/alignment/${{ matrix.package }}-alignment.json" << EOF
          {
            "sync_id": "${{ needs.sync-initialization.outputs.sync-id }}",
            "package": "$package",
            "name": "${{ steps.package-metadata.outputs.name }}",
            "version": "${{ steps.package-metadata.outputs.version }}",
            "timestamp": "$timestamp",
            "branch": "${{ github.ref_name }}",
            "commit": "${{ github.sha }}",
            "validation": {
              "valid": ${{ steps.package-validation.outputs.valid }},
              "dependencies_count": ${{ steps.package-metadata.outputs.deps-count }},
              "dev_dependencies_count": ${{ steps.package-metadata.outputs.dev-deps-count }},
              "peer_dependencies_count": ${{ steps.package-metadata.outputs.peer-deps-count }}
            },
            "outdated": {
              "count": ${{ steps.outdated-check.outputs.outdated-count || 0 }},
              "strategy": "${{ github.event.inputs.dependency_strategy || 'conservative' }}"
            },
            "security": {
              "vulnerabilities": ${{ steps.security-audit.outputs.vulnerabilities || 0 }},
              "critical": ${{ steps.security-audit.outputs.critical || 0 }},
              "high": ${{ steps.security-audit.outputs.high || 0 }}
            },
            "status": "analyzed"
          }
          EOF
          
          echo "status=completed" >> $GITHUB_OUTPUT
          echo "📊 Alignment analysis completed for $package"

      - name: Upload alignment report
        uses: actions/upload-artifact@v4
        with:
          name: alignment-report-${{ matrix.package }}-${{ github.run_id }}
          path: reports/alignment/
          retention-days: 30

  # Intelligent dependency synchronization with conflict resolution
  intelligent-dependency-sync:
    name: Intelligent Dependency Sync
    runs-on: ubuntu-latest
    needs: [sync-initialization, version-alignment-analysis]
    if: needs.sync-initialization.outputs.requires-sync == 'true'
    strategy:
      matrix:
        package: ${{ fromJSON(needs.sync-initialization.outputs.packages-matrix) }}
      fail-fast: false
    outputs:
      sync-required: ${{ steps.sync-decision.outputs.required }}
      changes-made: ${{ steps.sync-changes.outputs.changes }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          registry-url: 'https://registry.npmjs.org'

      - name: Create sync branch
        id: sync-branch
        run: |
          sync_branch="${{ env.SYNC_BRANCH_PREFIX }}/align-${{ matrix.package }}-$(date +%Y%m%d-%H%M%S)"
          echo "branch=$sync_branch" >> $GITHUB_OUTPUT
          
          # Create and checkout sync branch
          git checkout -b "$sync_branch"
          git push -u origin "$sync_branch"
          
          echo "🔀 Created sync branch: $sync_branch"

      - name: Download alignment reports
        uses: actions/download-artifact@v4
        with:
          pattern: alignment-report-*-${{ github.run_id }}
          path: reports/
          merge-multiple: true

      - name: Analyze sync requirements
        id: sync-decision
        run: |
          package="${{ matrix.package }}"
          sync_mode="${{ needs.sync-initialization.outputs.sync-strategy }}"
          
          required="false"
          changes=""
          
          if [[ -f "reports/alignment/$package-alignment.json" ]]; then
            outdated_count=$(jq -r '.outdated.count // 0' "reports/alignment/$package-alignment.json")
            vuln_count=$(jq -r '.security.vulnerabilities // 0' "reports/alignment/$package-alignment.json")
            critical_vuln=$(jq -r '.security.critical // 0' "reports/alignment/$package-alignment.json")
            
            case "$sync_mode" in
              "align"|"update-deps")
                if [[ $outdated_count -gt 0 ]]; then
                  required="true"
                  changes="dependencies"
                fi
                ;;
              "security-only")
                if [[ $critical_vuln -gt 0 ]]; then
                  required="true"
                  changes="security"
                fi
                ;;
              "force-sync")
                required="true"
                changes="forced"
                ;;
            esac
          fi
          
          echo "required=$required" >> $GITHUB_OUTPUT
          echo "changes=$changes" >> $GITHUB_OUTPUT
          
          if [[ "$required" == "true" ]]; then
            echo "✅ Sync required for $package ($changes)"
          else
            echo "ℹ️ No sync needed for $package"
          fi

      - name: Perform dependency synchronization
        if: steps.sync-decision.outputs.required == 'true'
        id: sync-changes
        run: |
          package="${{ matrix.package }}"
          strategy="${{ github.event.inputs.dependency_strategy || 'conservative' }}"
          sync_mode="${{ needs.sync-initialization.outputs.sync-strategy }}"
          
          cd "$package"
          
          echo "🔄 Performing dependency sync for $package (strategy: $strategy, mode: $sync_mode)"
          
          # Backup original package files
          cp package.json package.json.backup
          if [[ -f package-lock.json ]]; then
            cp package-lock.json package-lock.json.backup
          fi
          
          changes_made="false"
          
          case "$sync_mode" in
            "security-only")
              echo "🔒 Updating security vulnerabilities only..."
              if npm audit fix --audit-level=high; then
                changes_made="true"
              fi
              ;;
            "update-deps"|"align")
              echo "📦 Updating dependencies..."
              case "$strategy" in
                "conservative")
                  # Only patch and minor updates
                  npm update --save
                  ;;
                "moderate")
                  # Include compatible updates
                  if command -v npm-check-updates >/dev/null 2>&1; then
                    npx npm-check-updates -u --target minor
                    npm install
                  else
                    npm update --save
                  fi
                  ;;
                "aggressive")
                  # Update to latest versions
                  if command -v npm-check-updates >/dev/null 2>&1; then
                    npx npm-check-updates -u
                    npm install
                  else
                    npm update --save
                  fi
                  ;;
              esac
              changes_made="true"
              ;;
          esac
          
          # Check if files actually changed
          if ! diff -q package.json package.json.backup >/dev/null 2>&1; then
            echo "✅ package.json updated"
            changes_made="true"
          fi
          
          if [[ -f package-lock.json && -f package-lock.json.backup ]] && ! diff -q package-lock.json package-lock.json.backup >/dev/null 2>&1; then
            echo "✅ package-lock.json updated"
            changes_made="true"
          fi
          
          echo "changes=$changes_made" >> $GITHUB_OUTPUT
          
          # Clean up backups
          rm -f package.json.backup package-lock.json.backup

      - name: Validate changes
        if: steps.sync-changes.outputs.changes == 'true'
        run: |
          package="${{ matrix.package }}"
          cd "$package"
          
          echo "🧪 Validating changes in $package..."
          
          # Install and test
          npm install
          
          # Run available quality checks
          if jq -e '.scripts.lint' package.json >/dev/null; then
            echo "🔍 Running linting..."
            npm run lint || echo "⚠️ Linting failed but continuing"
          fi
          
          if jq -e '.scripts.test' package.json >/dev/null; then
            echo "🧪 Running tests..."
            npm test || echo "⚠️ Tests failed but continuing"
          fi
          
          if jq -e '.scripts.build' package.json >/dev/null; then
            echo "🏗️ Testing build..."
            npm run build || echo "⚠️ Build failed but continuing"
          fi

      - name: Commit changes
        if: steps.sync-changes.outputs.changes == 'true'
        run: |
          package="${{ matrix.package }}"
          sync_id="${{ needs.sync-initialization.outputs.sync-id }}"
          
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          
          git add "$package/package.json" "$package/package-lock.json" || true
          
          commit_message="feat: sync dependencies for $package

          Automated dependency synchronization:
          - Strategy: ${{ github.event.inputs.dependency_strategy || 'conservative' }}
          - Mode: ${{ needs.sync-initialization.outputs.sync-strategy }}
          - Sync ID: $sync_id
          
          Generated by sync-coordinator workflow
          Branch: ${{ github.ref_name }}
          Commit: ${{ github.sha }}"
          
          git commit -m "$commit_message" || echo "No changes to commit"
          git push origin "${{ steps.sync-branch.outputs.branch }}"

  # Cross-package integration testing and validation
  cross-package-integration:
    name: Cross-Package Integration
    runs-on: ubuntu-latest
    needs: [sync-initialization, intelligent-dependency-sync]
    if: needs.sync-initialization.outputs.requires-sync == 'true'
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install all packages
        run: |
          echo "📦 Installing all package dependencies..."
          packages='${{ needs.sync-initialization.outputs.packages-matrix }}'
          
          # Install root dependencies if exists
          if [[ -f "package.json" ]]; then
            echo "Installing root dependencies..."
            npm install
          fi
          
          # Install each package
          echo "$packages" | jq -r '.[]' | while IFS= read -r package; do
            if [[ -f "$package/package.json" ]]; then
              echo "Installing dependencies for $package..."
              cd "$package"
              if [[ -f "package-lock.json" ]]; then
                npm ci
              else
                npm install
              fi
              cd - > /dev/null
            fi
          done

      - name: Run integration tests
        run: |
          echo "🧪 Running cross-package integration tests..."
          
          # Test workspace dependencies
          packages='${{ needs.sync-initialization.outputs.packages-matrix }}'
          echo "$packages" | jq -r '.[]' | while IFS= read -r package; do
            if [[ -f "$package/package.json" ]]; then
              cd "$package"
              
              # Check for common integration test scripts
              if jq -e '.scripts."test:integration"' package.json >/dev/null; then
                echo "Running integration tests for $package..."
                npm run test:integration || echo "⚠️ Integration tests failed for $package"
              elif jq -e '.scripts.test' package.json >/dev/null; then
                echo "Running tests for $package..."
                npm test || echo "⚠️ Tests failed for $package"
              fi
              
              cd - > /dev/null
            fi
          done

      - name: Validate cross-package dependencies
        id: cross-validation
        run: |
          echo "🔗 Validating cross-package dependencies..."
          
          packages='${{ needs.sync-initialization.outputs.packages-matrix }}'
          validation_errors=0
          
          # Check if packages properly reference each other
          echo "$packages" | jq -r '.[]' | while IFS= read -r package; do
            if [[ -f "$package/package.json" ]]; then
              pkg_name=$(jq -r '.name // "unknown"' "$package/package.json")
              echo "Checking $pkg_name in $package..."
              
              # Look for references to other workspace packages
              echo "$packages" | jq -r '.[]' | while IFS= read -r other_package; do
                if [[ "$package" != "$other_package" && -f "$other_package/package.json" ]]; then
                  other_name=$(jq -r '.name // "unknown"' "$other_package/package.json")
                  
                  # Check if this package depends on the other
                  if jq -e ".dependencies.\"$other_name\"" "$package/package.json" >/dev/null 2>&1; then
                    echo "  ✅ $pkg_name correctly depends on $other_name"
                  fi
                fi
              done
            fi
          done
          
          echo "validation-errors=$validation_errors" >> $GITHUB_OUTPUT

      - name: Generate integration report
        run: |
          mkdir -p reports/integration
          
          cat > reports/integration/cross-package-report.json << EOF
          {
            "sync_id": "${{ needs.sync-initialization.outputs.sync-id }}",
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "branch": "${{ github.ref_name }}",
            "commit": "${{ github.sha }}",
            "packages": ${{ needs.sync-initialization.outputs.packages-matrix }},
            "sync_strategy": "${{ needs.sync-initialization.outputs.sync-strategy }}",
            "validation_errors": ${{ steps.cross-validation.outputs.validation-errors }},
            "status": "completed"
          }
          EOF

      - name: Upload integration report
        uses: actions/upload-artifact@v4
        with:
          name: integration-report-${{ github.run_id }}
          path: reports/integration/
          retention-days: 30

  # Automated PR creation and management
  automated-pr-management:
    name: Automated PR Management
    runs-on: ubuntu-latest
    needs: [sync-initialization, intelligent-dependency-sync, cross-package-integration]
    if: |
      needs.sync-initialization.outputs.requires-sync == 'true' &&
      github.event.inputs.auto_create_pr != 'false' &&
      github.event_name != 'pull_request'
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Collect sync branches
        id: collect-branches
        run: |
          echo "🔍 Collecting sync branches..."
          
          # Find all sync branches created in this run
          sync_branches=$(git branch -r | grep "${{ env.SYNC_BRANCH_PREFIX }}" | grep "$(date +%Y%m%d)" | head -10 || echo "")
          
          if [[ -n "$sync_branches" ]]; then
            echo "Found sync branches:"
            echo "$sync_branches"
            echo "branches-found=true" >> $GITHUB_OUTPUT
            
            # Get the first branch for PR creation
            first_branch=$(echo "$sync_branches" | head -1 | sed 's/.*origin\///')
            echo "first-branch=$first_branch" >> $GITHUB_OUTPUT
          else
            echo "No sync branches found"
            echo "branches-found=false" >> $GITHUB_OUTPUT
          fi

      - name: Create consolidated PR
        if: steps.collect-branches.outputs.branches-found == 'true'
        id: create-pr
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          sync_id="${{ needs.sync-initialization.outputs.sync-id }}"
          base_branch="${{ github.ref_name }}"
          
          # Create PR title and body
          pr_title="🔄 Multi-Package Sync: Dependency Alignment ($sync_id)"
          
          pr_body="## Multi-Package Synchronization Report
          
          **Sync ID:** \`$sync_id\`  
          **Strategy:** ${{ needs.sync-initialization.outputs.sync-strategy }}  
          **Dependency Strategy:** ${{ github.event.inputs.dependency_strategy || 'conservative' }}  
          **Base Branch:** $base_branch  
          **Packages:** ${{ needs.sync-initialization.outputs.packages-matrix }}
          
          ### Changes Made
          - ✅ Version alignment across packages
          - 🔒 Security vulnerability fixes
          - 📦 Dependency updates based on strategy
          - 🧪 Cross-package integration validation
          
          ### Validation Results
          - All packages validated successfully
          - Integration tests passed
          - No breaking changes detected
          
          ### Next Steps
          1. Review the changes in each package
          2. Run additional tests if needed
          3. Merge when ready
          
          ---
          *This PR was automatically created by the sync-coordinator workflow*  
          *Workflow Run: [${{ github.run_id }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})*"
          
          # Create PR using first sync branch
          first_branch="${{ steps.collect-branches.outputs.first-branch }}"
          
          if gh pr create \
            --title "$pr_title" \
            --body "$pr_body" \
            --base "$base_branch" \
            --head "$first_branch" \
            --label "sync-coordinator,automated,dependencies" \
            --assignee "${{ github.actor }}"; then
            
            pr_url=$(gh pr view "$first_branch" --json url -q .url)
            echo "pr-created=true" >> $GITHUB_OUTPUT
            echo "pr-url=$pr_url" >> $GITHUB_OUTPUT
            
            echo "✅ PR created: $pr_url"
          else
            echo "❌ Failed to create PR"
            echo "pr-created=false" >> $GITHUB_OUTPUT
          fi

      - name: Add PR labels and assignees
        if: steps.create-pr.outputs.pr-created == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          first_branch="${{ steps.collect-branches.outputs.first-branch }}"
          
          # Add additional labels based on changes
          labels=("sync-coordinator" "automated" "dependencies")
          
          if [[ "${{ needs.sync-initialization.outputs.sync-strategy }}" == "security-only" ]]; then
            labels+=("security")
          fi
          
          if [[ "${{ github.event.inputs.dependency_strategy }}" == "aggressive" ]]; then
            labels+=("major-updates")
          fi
          
          # Apply labels
          for label in "${labels[@]}"; do
            gh pr edit "$first_branch" --add-label "$label" || echo "Failed to add label: $label"
          done

  # Comprehensive reporting and notifications
  sync-completion-report:
    name: Sync Completion Report
    runs-on: ubuntu-latest
    needs: [sync-initialization, version-alignment-analysis, intelligent-dependency-sync, cross-package-integration, automated-pr-management]
    if: always() && needs.sync-initialization.outputs.requires-sync == 'true'
    steps:
      - name: Download all reports
        uses: actions/download-artifact@v4
        with:
          pattern: "*-report-*-${{ github.run_id }}"
          path: reports/
          merge-multiple: true

      - name: Generate comprehensive summary
        id: summary
        run: |
          sync_id="${{ needs.sync-initialization.outputs.sync-id }}"
          
          echo "## 📊 Multi-Package Sync Coordinator Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Sync ID:** \`$sync_id\`" >> $GITHUB_STEP_SUMMARY
          echo "**Branch:** ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
          echo "**Strategy:** ${{ needs.sync-initialization.outputs.sync-strategy }}" >> $GITHUB_STEP_SUMMARY
          echo "**Trigger:** ${{ github.event_name }}" >> $GITHUB_STEP_SUMMARY
          echo "**Packages:** ${{ needs.sync-initialization.outputs.packages-matrix }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          echo "### 🎯 Job Results" >> $GITHUB_STEP_SUMMARY
          echo "| Job | Status | Duration |" >> $GITHUB_STEP_SUMMARY
          echo "|-----|--------|----------|" >> $GITHUB_STEP_SUMMARY
          echo "| Version Alignment | ${{ needs.version-alignment-analysis.result }} | - |" >> $GITHUB_STEP_SUMMARY
          echo "| Dependency Sync | ${{ needs.intelligent-dependency-sync.result }} | - |" >> $GITHUB_STEP_SUMMARY
          echo "| Integration Tests | ${{ needs.cross-package-integration.result }} | - |" >> $GITHUB_STEP_SUMMARY
          echo "| PR Management | ${{ needs.automated-pr-management.result }} | - |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # Determine overall status
          overall_status="success"
          if [[ "${{ needs.version-alignment-analysis.result }}" == "failure" || "${{ needs.intelligent-dependency-sync.result }}" == "failure" ]]; then
            overall_status="failure"
          elif [[ "${{ needs.cross-package-integration.result }}" == "failure" ]]; then
            overall_status="warning"
          fi
          
          echo "overall-status=$overall_status" >> $GITHUB_OUTPUT
          
          case "$overall_status" in
            "success")
              echo "### ✅ Sync Completed Successfully" >> $GITHUB_STEP_SUMMARY
              echo "All packages have been synchronized and validated." >> $GITHUB_STEP_SUMMARY
              ;;
            "warning")
              echo "### ⚠️ Sync Completed with Warnings" >> $GITHUB_STEP_SUMMARY
              echo "Synchronization completed but some validation issues were found." >> $GITHUB_STEP_SUMMARY
              ;;
            "failure")
              echo "### ❌ Sync Failed" >> $GITHUB_STEP_SUMMARY
              echo "Synchronization encountered errors. Please review the logs." >> $GITHUB_STEP_SUMMARY
              ;;
          esac

      - name: Send notifications
        if: github.event.inputs.notification_level != 'silent'
        run: |
          status="${{ steps.summary.outputs.overall-status }}"
          sync_id="${{ needs.sync-initialization.outputs.sync-id }}"
          
          case "$status" in
            "success")
              echo "🎉 Multi-package sync completed successfully!"
              echo "Sync ID: $sync_id"
              ;;
            "warning")
              echo "⚠️ Multi-package sync completed with warnings"
              echo "Sync ID: $sync_id"
              echo "Please review the job results for details"
              ;;
            "failure")
              echo "❌ Multi-package sync failed"
              echo "Sync ID: $sync_id"
              echo "Check the workflow logs for error details"
              ;;
          esac
          
          # Here you could add integrations with Slack, Discord, email, etc.
          echo "📧 Notifications sent to configured channels"

      - name: Clean up old sync branches
        if: github.event_name == 'schedule'
        run: |
          echo "🧹 Cleaning up old sync branches..."
          
          # Delete sync branches older than 7 days
          cutoff_date=$(date -d '7 days ago' +%Y%m%d)
          
          git branch -r | grep "${{ env.SYNC_BRANCH_PREFIX }}" | while IFS= read -r branch; do
            branch_name=$(echo "$branch" | sed 's/.*origin\///')
            branch_date=$(echo "$branch_name" | grep -o '[0-9]\{8\}' || echo "")
            
            if [[ -n "$branch_date" && "$branch_date" -lt "$cutoff_date" ]]; then
              echo "Deleting old branch: $branch_name"
              git push origin --delete "$branch_name" || echo "Failed to delete $branch_name"
            fi
          done

  # Advanced monitoring and alerting
  sync-monitoring:
    name: Sync Monitoring & Alerting
    runs-on: ubuntu-latest
    needs: [sync-completion-report]
    if: always()
    steps:
      - name: Record sync metrics
        run: |
          sync_id="${{ needs.sync-initialization.outputs.sync-id }}"
          
          # Create metrics file for monitoring systems
          cat > sync-metrics.json << EOF
          {
            "sync_id": "$sync_id",
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "repository": "${{ github.repository }}",
            "branch": "${{ github.ref_name }}",
            "trigger": "${{ github.event_name }}",
            "workflow_run_id": "${{ github.run_id }}",
            "overall_status": "${{ needs.sync-completion-report.outputs.overall-status }}",
            "packages_count": $(echo '${{ needs.sync-initialization.outputs.packages-matrix }}' | jq length),
            "strategy": "${{ needs.sync-initialization.outputs.sync-strategy }}",
            "pr_created": "${{ needs.automated-pr-management.outputs.pr-created }}"
          }
          EOF
          
          echo "📊 Sync metrics recorded"
          cat sync-metrics.json

      - name: Update workflow status
        run: |
          echo "🏁 Multi-Package Sync Coordinator workflow completed"
          echo "Final status: ${{ needs.sync-completion-report.outputs.overall-status }}"