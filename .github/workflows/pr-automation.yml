name: Automated PR Management & Validation
# Advanced PR automation with intelligent validation, auto-assignment, and smart merging

on:
  pull_request:
    types: [opened, synchronize, reopened, edited, ready_for_review]
    branches: [main, development, test, dev]
  pull_request_review:
    types: [submitted, edited, dismissed]
  issue_comment:
    types: [created, edited]
  workflow_dispatch:
    inputs:
      pr_number:
        description: 'PR number to process'
        required: true
        type: number
      action:
        description: 'Action to perform'
        required: true
        type: choice
        options:
          - validate
          - auto-assign
          - update-labels
          - check-merge-ready
          - auto-merge

env:
  NODE_VERSION: '20'
  AUTO_MERGE_LABEL: 'auto-merge'
  NEEDS_REVIEW_LABEL: 'needs-review'
  READY_TO_MERGE_LABEL: 'ready-to-merge'

permissions:
  contents: write
  pull-requests: write
  checks: write
  issues: write
  repository-projects: write

jobs:
  pr-analysis:
    name: PR Analysis & Classification
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request' || github.event_name == 'workflow_dispatch'
    outputs:
      pr-type: ${{ steps.classify-pr.outputs.type }}
      complexity-score: ${{ steps.analyze-complexity.outputs.score }}
      requires-review: ${{ steps.review-requirements.outputs.required }}
      auto-merge-eligible: ${{ steps.auto-merge-check.outputs.eligible }}
      files-changed: ${{ steps.file-analysis.outputs.count }}
      critical-files-changed: ${{ steps.file-analysis.outputs.critical }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Get PR information
        id: pr-info
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            pr_number="${{ github.event.inputs.pr_number }}"
          else
            pr_number="${{ github.event.pull_request.number }}"
          fi
          
          pr_data=$(gh pr view $pr_number --json title,body,author,labels,reviewRequests,reviews,mergeable,baseRefName,headRefName,changedFiles,additions,deletions)
          
          echo "number=$pr_number" >> $GITHUB_OUTPUT
          echo "title=$(echo "$pr_data" | jq -r '.title')" >> $GITHUB_OUTPUT
          echo "author=$(echo "$pr_data" | jq -r '.author.login')" >> $GITHUB_OUTPUT
          echo "base-branch=$(echo "$pr_data" | jq -r '.baseRefName')" >> $GITHUB_OUTPUT
          echo "head-branch=$(echo "$pr_data" | jq -r '.headRefName')" >> $GITHUB_OUTPUT
          echo "mergeable=$(echo "$pr_data" | jq -r '.mergeable')" >> $GITHUB_OUTPUT
          echo "files-changed=$(echo "$pr_data" | jq -r '.changedFiles')" >> $GITHUB_OUTPUT
          echo "additions=$(echo "$pr_data" | jq -r '.additions')" >> $GITHUB_OUTPUT
          echo "deletions=$(echo "$pr_data" | jq -r '.deletions')" >> $GITHUB_OUTPUT

      - name: Classify PR type
        id: classify-pr
        run: |
          title="${{ steps.pr-info.outputs.title }}"
          head_branch="${{ steps.pr-info.outputs.head-branch }}"
          
          # Classify based on conventional commits and branch patterns
          type="feature"
          
          if [[ "$title" =~ ^feat(\(.+\))?: ]]; then
            type="feature"
          elif [[ "$title" =~ ^fix(\(.+\))?: ]]; then
            type="bugfix"
          elif [[ "$title" =~ ^docs(\(.+\))?: ]]; then
            type="documentation"
          elif [[ "$title" =~ ^style(\(.+\))?: ]]; then
            type="style"
          elif [[ "$title" =~ ^refactor(\(.+\))?: ]]; then
            type="refactor"
          elif [[ "$title" =~ ^test(\(.+\))?: ]]; then
            type="test"
          elif [[ "$title" =~ ^chore(\(.+\))?: ]]; then
            type="chore"
          elif [[ "$title" =~ ^ci(\(.+\))?: ]]; then
            type="ci"
          elif [[ "$head_branch" =~ ^hotfix/ ]]; then
            type="hotfix"
          elif [[ "$head_branch" =~ ^sync-coordinator/ ]]; then
            type="dependency-sync"
          elif [[ "$head_branch" =~ ^dependabot/ ]]; then
            type="dependency-update"
          fi
          
          echo "type=$type" >> $GITHUB_OUTPUT
          echo "üè∑Ô∏è PR classified as: $type"

      - name: Analyze complexity
        id: analyze-complexity
        run: |
          files_changed=${{ steps.pr-info.outputs.files-changed }}
          additions=${{ steps.pr-info.outputs.additions }}
          deletions=${{ steps.pr-info.outputs.deletions }}
          
          # Calculate complexity score (0-100)
          complexity=0
          
          # File count impact (0-30 points)
          if [[ $files_changed -le 3 ]]; then
            complexity=$((complexity + 5))
          elif [[ $files_changed -le 10 ]]; then
            complexity=$((complexity + 15))
          elif [[ $files_changed -le 20 ]]; then
            complexity=$((complexity + 25))
          else
            complexity=$((complexity + 30))
          fi
          
          # Lines changed impact (0-40 points)
          total_changes=$((additions + deletions))
          if [[ $total_changes -le 50 ]]; then
            complexity=$((complexity + 5))
          elif [[ $total_changes -le 200 ]]; then
            complexity=$((complexity + 15))
          elif [[ $total_changes -le 500 ]]; then
            complexity=$((complexity + 25))
          else
            complexity=$((complexity + 40))
          fi
          
          # Branch and type impact (0-30 points)
          base_branch="${{ steps.pr-info.outputs.base-branch }}"
          pr_type="${{ steps.classify-pr.outputs.type }}"
          
          if [[ "$base_branch" == "main" ]]; then
            complexity=$((complexity + 20))
          elif [[ "$base_branch" == "development" ]]; then
            complexity=$((complexity + 10))
          fi
          
          if [[ "$pr_type" == "hotfix" ]]; then
            complexity=$((complexity + 15))
          elif [[ "$pr_type" == "feature" ]]; then
            complexity=$((complexity + 10))
          fi
          
          echo "score=$complexity" >> $GITHUB_OUTPUT
          echo "üìä Complexity score: $complexity/100"

      - name: Analyze changed files
        id: file-analysis
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          pr_number="${{ steps.pr-info.outputs.number }}"
          
          # Get list of changed files
          changed_files=$(gh pr diff $pr_number --name-only)
          files_count=$(echo "$changed_files" | wc -l)
          
          # Check for critical files
          critical_files=()
          while IFS= read -r file; do
            case "$file" in
              package.json|package-lock.json|*.lock|yarn.lock)
                critical_files+=("dependency:$file")
                ;;
              .github/workflows/*.yml|.github/workflows/*.yaml)
                critical_files+=("workflow:$file")
                ;;
              Dockerfile|docker-compose*.yml|*.dockerfile)
                critical_files+=("docker:$file")
                ;;
              prisma/schema.prisma|**/migrations/*)
                critical_files+=("database:$file")
                ;;
              .env*|config/*.json|*.config.js|*.config.ts)
                critical_files+=("config:$file")
                ;;
              src/types/*|shared/types/*|**/types.ts)
                critical_files+=("types:$file")
                ;;
            esac
          done <<< "$changed_files"
          
          critical_count=${#critical_files[@]}
          
          echo "count=$files_count" >> $GITHUB_OUTPUT
          echo "critical=$critical_count" >> $GITHUB_OUTPUT
          
          if [[ $critical_count -gt 0 ]]; then
            echo "‚ö†Ô∏è Critical files changed: $critical_count"
            printf '%s\n' "${critical_files[@]}" | head -5
          else
            echo "‚úÖ No critical files changed"
          fi

      - name: Determine review requirements
        id: review-requirements
        run: |
          complexity=${{ steps.analyze-complexity.outputs.score }}
          critical_files=${{ steps.file-analysis.outputs.critical }}
          pr_type="${{ steps.classify-pr.outputs.type }}"
          base_branch="${{ steps.pr-info.outputs.base-branch }}"
          author="${{ steps.pr-info.outputs.author }}"
          
          required="true"
          min_reviewers=1
          
          # Determine review requirements
          if [[ "$pr_type" == "dependency-sync" && $complexity -lt 30 ]]; then
            required="false"
            min_reviewers=0
          elif [[ "$pr_type" == "dependency-update" && $complexity -lt 20 ]]; then
            required="false"
            min_reviewers=0
          elif [[ "$pr_type" == "documentation" && $complexity -lt 25 ]]; then
            min_reviewers=1
          elif [[ "$base_branch" == "main" ]]; then
            min_reviewers=2
          elif [[ $critical_files -gt 0 ]]; then
            min_reviewers=2
          elif [[ $complexity -gt 70 ]]; then
            min_reviewers=2
          fi
          
          # Bot PRs have different requirements
          if [[ "$author" == "dependabot"* || "$author" == "github-actions"* ]]; then
            if [[ $complexity -lt 30 && $critical_files -eq 0 ]]; then
              required="false"
              min_reviewers=0
            fi
          fi
          
          echo "required=$required" >> $GITHUB_OUTPUT
          echo "min-reviewers=$min_reviewers" >> $GITHUB_OUTPUT
          
          echo "üîç Review required: $required (min reviewers: $min_reviewers)"

      - name: Check auto-merge eligibility
        id: auto-merge-check
        run: |
          pr_type="${{ steps.classify-pr.outputs.type }}"
          complexity=${{ steps.analyze-complexity.outputs.score }}
          critical_files=${{ steps.file-analysis.outputs.critical }}
          review_required="${{ steps.review-requirements.outputs.required }}"
          base_branch="${{ steps.pr-info.outputs.base-branch }}"
          author="${{ steps.pr-info.outputs.author }}"
          
          eligible="false"
          
          # Auto-merge eligibility criteria
          if [[ "$review_required" == "false" && $complexity -lt 40 && $critical_files -eq 0 ]]; then
            case "$pr_type" in
              "dependency-sync"|"dependency-update"|"chore"|"ci")
                if [[ "$base_branch" != "main" ]]; then
                  eligible="true"
                fi
                ;;
              "documentation"|"style"|"test")
                if [[ $complexity -lt 25 ]]; then
                  eligible="true"
                fi
                ;;
            esac
          fi
          
          # Trusted authors can have more lenient auto-merge
          if [[ "$author" == "dependabot"* || "$author" == "github-actions"* ]]; then
            if [[ $complexity -lt 30 && "$base_branch" != "main" ]]; then
              eligible="true"
            fi
          fi
          
          echo "eligible=$eligible" >> $GITHUB_OUTPUT
          echo "ü§ñ Auto-merge eligible: $eligible"

  intelligent-assignment:
    name: Intelligent PR Assignment
    runs-on: ubuntu-latest
    needs: pr-analysis
    if: github.event_name == 'pull_request' && github.event.action == 'opened'
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Determine reviewers based on changes
        id: assign-reviewers
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          pr_number="${{ github.event.pull_request.number }}"
          pr_type="${{ needs.pr-analysis.outputs.pr-type }}"
          critical_files="${{ needs.pr-analysis.outputs.critical-files-changed }}"
          min_reviewers="${{ needs.pr-analysis.outputs.requires-review }}"
          
          echo "üéØ Determining reviewers for $pr_type PR..."
          
          # Get changed files to determine expertise areas
          changed_files=$(gh pr diff $pr_number --name-only)
          
          reviewers=()
          teams=()
          
          # Analyze file patterns for reviewer assignment
          while IFS= read -r file; do
            case "$file" in
              backend/*)
                reviewers+=("backend-team")
                teams+=("backend")
                ;;
              frontend/*)
                reviewers+=("frontend-team")
                teams+=("frontend")
                ;;
              shared/*)
                reviewers+=("backend-team" "frontend-team")
                teams+=("shared")
                ;;
              .github/workflows/*)
                reviewers+=("devops-team")
                teams+=("devops")
                ;;
              **/test*|**/*.test.*|**/*.spec.*)
                teams+=("qa")
                ;;
              docs/*|*.md|README*)
                teams+=("documentation")
                ;;
            esac
          done <<< "$changed_files"
          
          # Remove duplicates and limit reviewers
          unique_reviewers=($(printf '%s\n' "${reviewers[@]}" | sort -u | head -3))
          unique_teams=($(printf '%s\n' "${teams[@]}" | sort -u | head -2))
          
          echo "üë• Suggested reviewers: ${unique_reviewers[*]}"
          echo "üè¢ Suggested teams: ${unique_teams[*]}"
          
          # Apply assignments (customize based on your team structure)
          if [[ ${#unique_reviewers[@]} -gt 0 ]]; then
            echo "Reviewers would be assigned: ${unique_reviewers[*]}"
            # gh pr edit $pr_number --add-assignee "${unique_reviewers[*]}"
          fi

      - name: Apply intelligent labels
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          pr_number="${{ github.event.pull_request.number }}"
          pr_type="${{ needs.pr-analysis.outputs.pr-type }}"
          complexity="${{ needs.pr-analysis.outputs.complexity-score }}"
          auto_merge="${{ needs.pr-analysis.outputs.auto-merge-eligible }}"
          
          labels=()
          
          # Type-based labels
          case "$pr_type" in
            "feature") labels+=("enhancement" "feature") ;;
            "bugfix") labels+=("bug" "fix") ;;
            "hotfix") labels+=("hotfix" "critical") ;;
            "documentation") labels+=("documentation") ;;
            "dependency-sync") labels+=("dependencies" "sync-coordinator") ;;
            "dependency-update") labels+=("dependencies" "automated") ;;
            "test") labels+=("tests") ;;
            "ci") labels+=("ci" "workflow") ;;
            "chore") labels+=("chore") ;;
          esac
          
          # Complexity-based labels
          if [[ $complexity -lt 25 ]]; then
            labels+=("low-complexity")
          elif [[ $complexity -lt 60 ]]; then
            labels+=("medium-complexity")
          else
            labels+=("high-complexity")
          fi
          
          # Auto-merge eligibility
          if [[ "$auto_merge" == "true" ]]; then
            labels+=("$AUTO_MERGE_LABEL")
          else
            labels+=("$NEEDS_REVIEW_LABEL")
          fi
          
          # Apply labels
          for label in "${labels[@]}"; do
            gh pr edit $pr_number --add-label "$label" || echo "Failed to add label: $label"
          done
          
          echo "üè∑Ô∏è Applied labels: ${labels[*]}"

  automated-validation:
    name: Automated PR Validation
    runs-on: ubuntu-latest
    needs: pr-analysis
    if: github.event_name == 'pull_request'
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Validate PR title and description
        id: title-validation
        run: |
          title="${{ github.event.pull_request.title }}"
          body="${{ github.event.pull_request.body }}"
          
          validation_errors=()
          
          # Check conventional commit format
          if ! [[ "$title" =~ ^(feat|fix|docs|style|refactor|test|chore|ci)(\(.+\))?: ]]; then
            validation_errors+=("Title does not follow conventional commit format")
          fi
          
          # Check title length
          if [[ ${#title} -gt 72 ]]; then
            validation_errors+=("Title exceeds 72 characters")
          fi
          
          # Check for description
          if [[ -z "$body" || ${#body} -lt 20 ]]; then
            validation_errors+=("PR description is too short or missing")
          fi
          
          # Check for issue reference (optional but recommended)
          if [[ ! "$body" =~ (fixes|closes|resolves|addresses)\ #[0-9]+ ]]; then
            echo "‚ÑπÔ∏è No issue reference found (recommended but not required)"
          fi
          
          if [[ ${#validation_errors[@]} -eq 0 ]]; then
            echo "validation-status=passed" >> $GITHUB_OUTPUT
            echo "‚úÖ PR title and description validation passed"
          else
            echo "validation-status=failed" >> $GITHUB_OUTPUT
            echo "‚ùå PR validation failed:"
            printf '%s\n' "${validation_errors[@]}"
            
            # Post validation errors as comment
            error_message="## ‚ùå PR Validation Failed\n\nThe following issues were found:\n\n"
            for error in "${validation_errors[@]}"; do
              error_message+="- $error\n"
            done
            error_message+="\nPlease fix these issues and update your PR."
            
            echo "validation-errors<<EOF" >> $GITHUB_OUTPUT
            echo -e "$error_message" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
          fi

      - name: Check for merge conflicts
        id: conflict-check
        run: |
          if [[ "${{ github.event.pull_request.mergeable }}" == "false" ]]; then
            echo "conflicts=true" >> $GITHUB_OUTPUT
            echo "‚ùå Merge conflicts detected"
          else
            echo "conflicts=false" >> $GITHUB_OUTPUT
            echo "‚úÖ No merge conflicts"
          fi

      - name: Validate branch naming
        id: branch-validation
        run: |
          head_branch="${{ github.event.pull_request.head.ref }}"
          
          valid_patterns=(
            "^feature/"
            "^bugfix/"
            "^hotfix/"
            "^chore/"
            "^docs/"
            "^test/"
            "^ci/"
            "^sync-coordinator/"
            "^dependabot/"
          )
          
          valid=false
          for pattern in "${valid_patterns[@]}"; do
            if [[ "$head_branch" =~ $pattern ]]; then
              valid=true
              break
            fi
          done
          
          if [[ "$valid" == "true" ]]; then
            echo "branch-valid=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Branch name follows conventions: $head_branch"
          else
            echo "branch-valid=false" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è Branch name doesn't follow conventions: $head_branch"
            echo "Recommended patterns: feature/, bugfix/, hotfix/, chore/, docs/, test/, ci/"
          fi

      - name: Post validation results
        if: steps.title-validation.outputs.validation-status == 'failed'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          pr_number="${{ github.event.pull_request.number }}"
          
          gh pr comment $pr_number --body "${{ steps.title-validation.outputs.validation-errors }}"

  smart-merge-check:
    name: Smart Merge Readiness Check
    runs-on: ubuntu-latest
    needs: [pr-analysis, automated-validation]
    if: |
      github.event_name == 'pull_request' &&
      (github.event.action == 'synchronize' || github.event.action == 'ready_for_review') ||
      github.event_name == 'pull_request_review'
    steps:
      - name: Check merge readiness
        id: merge-ready
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          pr_number="${{ github.event.pull_request.number || github.event.pull_request.number }}"
          
          # Get PR status
          pr_data=$(gh pr view $pr_number --json mergeable,reviewDecision,statusCheckRollup,labels)
          
          mergeable=$(echo "$pr_data" | jq -r '.mergeable')
          review_decision=$(echo "$pr_data" | jq -r '.reviewDecision')
          status_checks=$(echo "$pr_data" | jq -r '.statusCheckRollup[].conclusion' 2>/dev/null | grep -v "null" | sort -u)
          
          ready=true
          reasons=()
          
          # Check mergeable status
          if [[ "$mergeable" != "MERGEABLE" ]]; then
            ready=false
            reasons+=("PR is not mergeable (conflicts or other issues)")
          fi
          
          # Check review requirements
          min_reviewers="${{ needs.pr-analysis.outputs.requires-review }}"
          if [[ "$min_reviewers" == "true" ]]; then
            if [[ "$review_decision" != "APPROVED" ]]; then
              ready=false
              reasons+=("Required reviews not yet approved")
            fi
          fi
          
          # Check status checks
          if echo "$status_checks" | grep -q "FAILURE"; then
            ready=false
            reasons+=("Some status checks are failing")
          fi
          
          echo "ready=$ready" >> $GITHUB_OUTPUT
          
          if [[ "$ready" == "true" ]]; then
            echo "‚úÖ PR is ready to merge"
            
            # Add ready-to-merge label
            gh pr edit $pr_number --add-label "$READY_TO_MERGE_LABEL"
            gh pr edit $pr_number --remove-label "$NEEDS_REVIEW_LABEL" || true
          else
            echo "‚ùå PR not ready to merge:"
            printf '%s\n' "${reasons[@]}"
            
            # Remove ready-to-merge label
            gh pr edit $pr_number --remove-label "$READY_TO_MERGE_LABEL" || true
          fi

  auto-merge-execution:
    name: Auto-Merge Execution
    runs-on: ubuntu-latest
    needs: [pr-analysis, smart-merge-check]
    if: |
      needs.pr-analysis.outputs.auto-merge-eligible == 'true' &&
      needs.smart-merge-check.outputs.ready == 'true' &&
      (github.event_name == 'pull_request_review' ||
       github.event_name == 'workflow_dispatch')
    steps:
      - name: Execute auto-merge
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          pr_number="${{ github.event.pull_request.number || github.event.inputs.pr_number }}"
          
          echo "ü§ñ Executing auto-merge for PR #$pr_number"
          
          # Final safety check
          pr_data=$(gh pr view $pr_number --json labels,mergeable,reviewDecision)
          labels=$(echo "$pr_data" | jq -r '.labels[].name' | tr '\n' ' ')
          
          if [[ "$labels" =~ $AUTO_MERGE_LABEL ]] && [[ "$labels" =~ $READY_TO_MERGE_LABEL ]]; then
            if gh pr merge $pr_number --auto --squash; then
              echo "‚úÖ Auto-merge enabled for PR #$pr_number"
              
              # Post success comment
              gh pr comment $pr_number --body "ü§ñ Auto-merge has been enabled for this PR. It will be automatically merged once all checks pass."
            else
              echo "‚ùå Failed to enable auto-merge"
            fi
          else
            echo "‚ùå PR not eligible for auto-merge (missing required labels)"
          fi

  pr-metrics-collection:
    name: PR Metrics Collection
    runs-on: ubuntu-latest
    needs: [pr-analysis]
    if: always() && github.event_name == 'pull_request'
    steps:
      - name: Collect and store PR metrics
        run: |
          pr_number="${{ github.event.pull_request.number }}"
          
          # Create metrics record
          cat > pr-metrics.json << EOF
          {
            "pr_number": $pr_number,
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "repository": "${{ github.repository }}",
            "author": "${{ github.event.pull_request.user.login }}",
            "type": "${{ needs.pr-analysis.outputs.pr-type }}",
            "complexity_score": ${{ needs.pr-analysis.outputs.complexity-score }},
            "files_changed": ${{ needs.pr-analysis.outputs.files-changed }},
            "critical_files_changed": ${{ needs.pr-analysis.outputs.critical-files-changed }},
            "auto_merge_eligible": ${{ needs.pr-analysis.outputs.auto-merge-eligible }},
            "review_required": ${{ needs.pr-analysis.outputs.requires-review }},
            "base_branch": "${{ github.event.pull_request.base.ref }}",
            "head_branch": "${{ github.event.pull_request.head.ref }}",
            "action": "${{ github.event.action }}"
          }
          EOF
          
          echo "üìä PR metrics collected"
          cat pr-metrics.json

      - name: Upload metrics
        uses: actions/upload-artifact@v4
        with:
          name: pr-metrics-${{ github.event.pull_request.number }}-${{ github.run_id }}
          path: pr-metrics.json
          retention-days: 90

  notification-management:
    name: Smart Notifications
    runs-on: ubuntu-latest
    needs: [pr-analysis, intelligent-assignment, automated-validation]
    if: always() && github.event_name == 'pull_request' && github.event.action == 'opened'
    steps:
      - name: Generate PR summary
        id: summary
        run: |
          pr_type="${{ needs.pr-analysis.outputs.pr-type }}"
          complexity="${{ needs.pr-analysis.outputs.complexity-score }}"
          auto_merge="${{ needs.pr-analysis.outputs.auto-merge-eligible }}"
          
          summary="## üìã PR Analysis Summary\n\n"
          summary+="**Type:** $pr_type\n"
          summary+="**Complexity Score:** $complexity/100\n"
          summary+="**Files Changed:** ${{ needs.pr-analysis.outputs.files-changed }}\n"
          summary+="**Critical Files:** ${{ needs.pr-analysis.outputs.critical-files-changed }}\n"
          summary+="**Auto-merge Eligible:** $auto_merge\n"
          summary+="**Review Required:** ${{ needs.pr-analysis.outputs.requires-review }}\n\n"
          
          if [[ "$auto_merge" == "true" ]]; then
            summary+="ü§ñ This PR is eligible for auto-merge once all checks pass.\n\n"
          fi
          
          summary+="---\n*Automated analysis by PR Management workflow*"
          
          echo "summary<<EOF" >> $GITHUB_OUTPUT
          echo -e "$summary" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Post PR analysis comment
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          pr_number="${{ github.event.pull_request.number }}"
          
          gh pr comment $pr_number --body "${{ steps.summary.outputs.summary }}"