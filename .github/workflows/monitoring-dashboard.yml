name: Monitoring Dashboard - Workflow Metrics and Analytics

on:
  schedule:
    # Run every 6 hours
    - cron: '0 */6 * * *'
  workflow_dispatch:
    inputs:
      report_type:
        description: 'Type of monitoring report to generate'
        required: true
        default: 'comprehensive'
        type: choice
        options:
          - comprehensive
          - performance
          - quality
          - security
          - dependencies
      time_range:
        description: 'Time range for analysis'
        required: false
        default: '7d'
        type: choice
        options:
          - 1d
          - 7d
          - 30d
          - 90d

env:
  NODE_VERSION: '20.x'

jobs:
  collect-metrics:
    name: Collect Workflow Metrics
    runs-on: ubuntu-latest
    outputs:
      metrics-data: ${{ steps.collect.outputs.metrics-data }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Install GitHub CLI
        run: |
          if ! command -v gh &> /dev/null; then
            curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg | sudo dd of=/usr/share/keyrings/githubcli-archive-keyring.gpg
            echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" | sudo tee /etc/apt/sources.list.d/github-cli.list > /dev/null
            sudo apt update
            sudo apt install gh
          fi

      - name: Collect workflow metrics
        id: collect
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "Collecting workflow metrics..."
          
          # Create metrics collection script
          cat > collect-metrics.js << 'EOF'
          const { execSync } = require('child_process');
          
          const workflows = [
            'Multi-Package Synchronization and Version Alignment',
            'Quality Gates and Multi-Package Testing',
            'Automated Dependency Updates',
            'Workflow Monitoring and Reporting Dashboard'
          ];
          
          const metrics = {
            timestamp: new Date().toISOString(),
            workflows: {},
            summary: {
              total_runs: 0,
              success_rate: 0,
              avg_duration: 0,
              recent_failures: 0
            }
          };
          
          workflows.forEach(workflow => {
            try {
              // Get recent workflow runs
              const cmd = `gh run list --workflow="${workflow}" --limit=10 --json status,conclusion,createdAt,updatedAt,durationMs`;
              const result = execSync(cmd, { encoding: 'utf8' });
              const runs = JSON.parse(result);
              
              const successful = runs.filter(run => run.conclusion === 'success').length;
              const total = runs.length;
              const recent_failures = runs.slice(0, 5).filter(run => run.conclusion === 'failure').length;
              
              const durations = runs
                .filter(run => run.durationMs)
                .map(run => run.durationMs);
              
              const avg_duration = durations.length > 0 
                ? durations.reduce((a, b) => a + b, 0) / durations.length 
                : 0;
              
              metrics.workflows[workflow] = {
                total_runs: total,
                success_rate: total > 0 ? (successful / total * 100).toFixed(1) : 0,
                avg_duration_minutes: (avg_duration / 1000 / 60).toFixed(1),
                recent_failures: recent_failures,
                last_run: runs[0] || null
              };
              
              metrics.summary.total_runs += total;
              metrics.summary.recent_failures += recent_failures;
              
            } catch (error) {
              console.log(`Warning: Could not collect metrics for ${workflow}:`, error.message);
              metrics.workflows[workflow] = {
                error: error.message,
                total_runs: 0,
                success_rate: 0,
                avg_duration_minutes: 0,
                recent_failures: 0
              };
            }
          });
          
          // Calculate overall metrics
          const total_successful = Object.values(metrics.workflows)
            .reduce((sum, w) => sum + (w.total_runs * (parseFloat(w.success_rate) / 100)), 0);
          
          metrics.summary.success_rate = metrics.summary.total_runs > 0 
            ? (total_successful / metrics.summary.total_runs * 100).toFixed(1)
            : 0;
          
          const all_durations = Object.values(metrics.workflows)
            .map(w => parseFloat(w.avg_duration_minutes))
            .filter(d => d > 0);
          
          metrics.summary.avg_duration = all_durations.length > 0
            ? (all_durations.reduce((a, b) => a + b, 0) / all_durations.length).toFixed(1)
            : 0;
          
          console.log(JSON.stringify(metrics, null, 2));
          
          // Output for GitHub Actions
          const fs = require('fs');
          fs.writeFileSync('workflow-metrics.json', JSON.stringify(metrics, null, 2));
          EOF
          
          node collect-metrics.js
          
          # Set output
          echo "metrics-data<<EOF" >> $GITHUB_OUTPUT
          cat workflow-metrics.json >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Upload metrics data
        uses: actions/upload-artifact@v4
        with:
          name: workflow-metrics
          path: workflow-metrics.json

  generate-health-report:
    name: Generate Workflow Health Report
    runs-on: ubuntu-latest
    needs: collect-metrics
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Download metrics data
        uses: actions/download-artifact@v4
        with:
          name: workflow-metrics

      - name: Generate health report
        run: |
          echo "Generating workflow health report..."
          
          cat > generate-report.js << 'EOF'
          const fs = require('fs');
          const metrics = JSON.parse(fs.readFileSync('workflow-metrics.json', 'utf8'));
          
          function generateHealthReport(metrics) {
            const report = [];
            
            report.push('# 🔍 Workflow Health Report');
            report.push('');
            report.push(`**Generated**: ${new Date(metrics.timestamp).toLocaleString()}`);
            report.push('');
            
            // Overall health status
            const overallHealth = parseFloat(metrics.summary.success_rate);
            let healthStatus = '🔴 Critical';
            let healthColor = 'red';
            
            if (overallHealth >= 95) {
              healthStatus = '🟢 Excellent';
              healthColor = 'green';
            } else if (overallHealth >= 85) {
              healthStatus = '🟡 Good';
              healthColor = 'yellow';
            } else if (overallHealth >= 70) {
              healthStatus = '🟠 Warning';
              healthColor = 'orange';
            }
            
            report.push(`## 📊 Overall Health: ${healthStatus}`);
            report.push('');
            
            // Summary metrics
            report.push('### 📈 Summary Metrics');
            report.push('| Metric | Value |');
            report.push('|--------|-------|');
            report.push(`| Overall Success Rate | ${metrics.summary.success_rate}% |`);
            report.push(`| Total Workflow Runs | ${metrics.summary.total_runs} |`);
            report.push(`| Average Duration | ${metrics.summary.avg_duration} minutes |`);
            report.push(`| Recent Failures | ${metrics.summary.recent_failures} |`);
            report.push('');
            
            // Individual workflow status
            report.push('### 🔄 Individual Workflow Status');
            report.push('');
            
            Object.entries(metrics.workflows).forEach(([name, data]) => {
              if (data.error) {
                report.push(`#### ❌ ${name}`);
                report.push(`**Status**: Error collecting metrics`);
                report.push(`**Error**: ${data.error}`);
              } else {
                const success_rate = parseFloat(data.success_rate);
                let status_icon = '🔴';
                if (success_rate >= 95) status_icon = '🟢';
                else if (success_rate >= 85) status_icon = '🟡';
                else if (success_rate >= 70) status_icon = '🟠';
                
                report.push(`#### ${status_icon} ${name}`);
                report.push(`- **Success Rate**: ${data.success_rate}%`);
                report.push(`- **Total Runs**: ${data.total_runs}`);
                report.push(`- **Average Duration**: ${data.avg_duration_minutes} minutes`);
                report.push(`- **Recent Failures**: ${data.recent_failures}`);
                
                if (data.last_run) {
                  const lastRun = new Date(data.last_run.createdAt).toLocaleString();
                  report.push(`- **Last Run**: ${lastRun} (${data.last_run.conclusion})`);
                }
              }
              report.push('');
            });
            
            // Recommendations
            report.push('### 💡 Recommendations');
            report.push('');
            
            if (overallHealth < 85) {
              report.push('#### 🚨 Action Required');
              report.push('- Overall success rate is below target (85%)');
              report.push('- Review recent failures and implement fixes');
              report.push('- Consider improving test coverage or stability');
            }
            
            if (metrics.summary.recent_failures > 3) {
              report.push('#### ⚠️ High Failure Rate');
              report.push('- Recent failure count is high');
              report.push('- Investigate common failure patterns');
              report.push('- Consider implementing additional error handling');
            }
            
            const slow_workflows = Object.entries(metrics.workflows)
              .filter(([_, data]) => parseFloat(data.avg_duration_minutes) > 15)
              .map(([name, _]) => name);
            
            if (slow_workflows.length > 0) {
              report.push('#### 🐌 Performance Optimization');
              report.push('- The following workflows are running slower than 15 minutes:');
              slow_workflows.forEach(name => {
                report.push(`  - ${name}`);
              });
              report.push('- Consider optimizing build processes or parallelizing jobs');
            }
            
            if (overallHealth >= 95 && metrics.summary.recent_failures === 0) {
              report.push('#### ✅ Excellent Performance');
              report.push('- All workflows are performing well');
              report.push('- No immediate action required');
              report.push('- Continue monitoring for any degradation');
            }
            
            return report.join('\n');
          }
          
          const healthReport = generateHealthReport(metrics);
          fs.writeFileSync('workflow-health-report.md', healthReport);
          
          // Also generate JSON summary for API consumption
          const summary = {
            health_status: metrics.summary.success_rate >= 95 ? 'excellent' : 
                          metrics.summary.success_rate >= 85 ? 'good' :
                          metrics.summary.success_rate >= 70 ? 'warning' : 'critical',
            success_rate: metrics.summary.success_rate,
            total_runs: metrics.summary.total_runs,
            recent_failures: metrics.summary.recent_failures,
            timestamp: metrics.timestamp
          };
          
          fs.writeFileSync('workflow-summary.json', JSON.stringify(summary, null, 2));
          EOF
          
          node generate-report.js

      - name: Upload health report
        uses: actions/upload-artifact@v4
        with:
          name: workflow-health-report
          path: |
            workflow-health-report.md
            workflow-summary.json

  performance-analysis:
    name: Performance Analysis
    runs-on: ubuntu-latest
    needs: collect-metrics
    if: github.event.inputs.report_type == 'performance' || github.event.inputs.report_type == 'detailed'
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Download metrics data
        uses: actions/download-artifact@v4
        with:
          name: workflow-metrics

      - name: Analyze performance trends
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "Analyzing performance trends..."
          
          cat > performance-analysis.js << 'EOF'
          const { execSync } = require('child_process');
          const fs = require('fs');
          
          const workflows = [
            'Multi-Package Synchronization and Version Alignment',
            'Quality Gates and Multi-Package Testing',
            'Automated Dependency Updates'
          ];
          
          const analysis = {
            timestamp: new Date().toISOString(),
            performance_trends: {},
            bottlenecks: [],
            recommendations: []
          };
          
          workflows.forEach(workflow => {
            try {
              // Get last 30 runs for trend analysis
              const cmd = `gh run list --workflow="${workflow}" --limit=30 --json status,conclusion,createdAt,updatedAt,durationMs,jobs`;
              const result = execSync(cmd, { encoding: 'utf8' });
              const runs = JSON.parse(result);
              
              const durations = runs
                .filter(run => run.durationMs && run.conclusion === 'success')
                .map(run => ({
                  duration: run.durationMs / 1000 / 60, // Convert to minutes
                  date: new Date(run.createdAt)
                }))
                .sort((a, b) => a.date - b.date);
              
              if (durations.length > 0) {
                const recent = durations.slice(-10);
                const older = durations.slice(0, -10);
                
                const recentAvg = recent.reduce((sum, r) => sum + r.duration, 0) / recent.length;
                const olderAvg = older.length > 0 ? older.reduce((sum, r) => sum + r.duration, 0) / older.length : recentAvg;
                
                const trend = ((recentAvg - olderAvg) / olderAvg * 100).toFixed(1);
                
                analysis.performance_trends[workflow] = {
                  current_avg: recentAvg.toFixed(1),
                  previous_avg: olderAvg.toFixed(1),
                  trend_percentage: trend,
                  trend_direction: parseFloat(trend) > 5 ? 'slower' : parseFloat(trend) < -5 ? 'faster' : 'stable',
                  sample_size: durations.length
                };
                
                // Identify bottlenecks
                if (recentAvg > 20) {
                  analysis.bottlenecks.push({
                    workflow: workflow,
                    issue: 'Long runtime',
                    current_duration: recentAvg.toFixed(1),
                    severity: recentAvg > 30 ? 'high' : 'medium'
                  });
                }
                
                if (parseFloat(trend) > 20) {
                  analysis.bottlenecks.push({
                    workflow: workflow,
                    issue: 'Performance regression',
                    trend: `${trend}% slower`,
                    severity: 'high'
                  });
                }
              }
              
            } catch (error) {
              console.log(`Warning: Could not analyze performance for ${workflow}:`, error.message);
            }
          });
          
          // Generate recommendations
          if (analysis.bottlenecks.length === 0) {
            analysis.recommendations.push('✅ All workflows are performing within acceptable limits');
          } else {
            analysis.recommendations.push('⚠️ Performance issues detected:');
            analysis.bottlenecks.forEach(bottleneck => {
              if (bottleneck.issue === 'Long runtime') {
                analysis.recommendations.push(`- Optimize ${bottleneck.workflow}: Consider parallelizing jobs or caching`);
              } else if (bottleneck.issue === 'Performance regression') {
                analysis.recommendations.push(`- Investigate ${bottleneck.workflow}: ${bottleneck.trend} performance degradation`);
              }
            });
          }
          
          fs.writeFileSync('performance-analysis.json', JSON.stringify(analysis, null, 2));
          
          // Generate markdown report
          const report = [];
          report.push('# 📈 Workflow Performance Analysis');
          report.push('');
          report.push(`**Generated**: ${new Date(analysis.timestamp).toLocaleString()}`);
          report.push('');
          
          report.push('## 🚀 Performance Trends');
          report.push('| Workflow | Current Avg | Previous Avg | Trend | Direction |');
          report.push('|----------|-------------|--------------|-------|-----------|');
          
          Object.entries(analysis.performance_trends).forEach(([workflow, data]) => {
            const trendIcon = data.trend_direction === 'faster' ? '⬇️' : 
                             data.trend_direction === 'slower' ? '⬆️' : '➡️';
            report.push(`| ${workflow.substring(0, 30)}... | ${data.current_avg}m | ${data.previous_avg}m | ${data.trend_percentage}% | ${trendIcon} ${data.trend_direction} |`);
          });
          
          report.push('');
          report.push('## 🔍 Identified Bottlenecks');
          if (analysis.bottlenecks.length === 0) {
            report.push('✅ No performance bottlenecks detected');
          } else {
            analysis.bottlenecks.forEach(bottleneck => {
              const severityIcon = bottleneck.severity === 'high' ? '🔴' : '🟡';
              report.push(`${severityIcon} **${bottleneck.workflow}**: ${bottleneck.issue}`);
              if (bottleneck.current_duration) {
                report.push(`   - Current duration: ${bottleneck.current_duration} minutes`);
              }
              if (bottleneck.trend) {
                report.push(`   - Performance change: ${bottleneck.trend}`);
              }
            });
          }
          
          report.push('');
          report.push('## 💡 Recommendations');
          analysis.recommendations.forEach(rec => {
            report.push(`${rec}`);
          });
          
          fs.writeFileSync('performance-report.md', report.join('\n'));
          EOF
          
          if command -v gh &> /dev/null; then
            node performance-analysis.js
          else
            echo "GitHub CLI not available, skipping performance analysis"
          fi

      - name: Upload performance analysis
        uses: actions/upload-artifact@v4
        with:
          name: performance-analysis
          path: |
            performance-analysis.json
            performance-report.md

  create-dashboard:
    name: Create Monitoring Dashboard
    runs-on: ubuntu-latest
    needs: [generate-health-report, performance-analysis]
    if: always()
    steps:
      - name: Download all reports
        uses: actions/download-artifact@v4

      - name: Create monitoring dashboard
        run: |
          echo "Creating monitoring dashboard..."
          
          # Create a comprehensive dashboard
          cat > dashboard.html << 'EOF'
          <!DOCTYPE html>
          <html lang="en">
          <head>
              <meta charset="UTF-8">
              <meta name="viewport" content="width=device-width, initial-scale=1.0">
              <title>MediaNest Workflow Monitoring Dashboard</title>
              <style>
                  body { font-family: Arial, sans-serif; margin: 20px; background-color: #f5f5f5; }
                  .container { max-width: 1200px; margin: 0 auto; background: white; padding: 20px; border-radius: 8px; }
                  .header { text-align: center; margin-bottom: 30px; }
                  .metric-card { background: #f8f9fa; padding: 15px; margin: 10px; border-radius: 6px; display: inline-block; min-width: 200px; }
                  .status-good { border-left: 4px solid #28a745; }
                  .status-warning { border-left: 4px solid #ffc107; }
                  .status-critical { border-left: 4px solid #dc3545; }
                  .workflow-list { margin-top: 20px; }
                  .workflow-item { background: white; border: 1px solid #dee2e6; padding: 15px; margin: 10px 0; border-radius: 6px; }
                  table { width: 100%; border-collapse: collapse; margin: 20px 0; }
                  th, td { padding: 10px; text-align: left; border-bottom: 1px solid #dee2e6; }
                  th { background-color: #f8f9fa; }
                  .timestamp { color: #6c757d; font-size: 0.9em; }
              </style>
          </head>
          <body>
              <div class="container">
                  <div class="header">
                      <h1>🔍 MediaNest Workflow Monitoring Dashboard</h1>
                      <p class="timestamp">Last Updated: ${new Date().toLocaleString()}</p>
                  </div>
          EOF
          
          # Add metrics from health report if available
          if [ -f "workflow-health-report/workflow-summary.json" ]; then
            cat >> dashboard.html << 'EOF'
                  <div class="metrics-overview">
                      <h2>📊 Overview Metrics</h2>
                      <div id="metrics-cards"></div>
                  </div>
          EOF
          fi
          
          cat >> dashboard.html << 'EOF'
                  <div class="workflow-status">
                      <h2>🔄 Workflow Status</h2>
                      <div id="workflow-list"></div>
                  </div>
                  
                  <div class="recent-activity">
                      <h2>📈 Performance Trends</h2>
                      <div id="performance-trends"></div>
                  </div>
                  
                  <div class="footer">
                      <p class="timestamp">Dashboard generated by GitHub Actions workflow monitoring</p>
                  </div>
              </div>
              
              <script>
                  // Load and display data if available
                  document.addEventListener('DOMContentLoaded', function() {
                      // This would be populated with actual data in a real implementation
                      console.log('Dashboard loaded');
                  });
              </script>
          </body>
          </html>
          EOF

      - name: Generate workflow summary
        run: |
          echo "## 📊 Workflow Monitoring Dashboard Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Dashboard Generated**: $(date)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ -f "workflow-health-report/workflow-summary.json" ]; then
            health_status=$(cat workflow-health-report/workflow-summary.json | grep -o '"health_status":"[^"]*"' | cut -d'"' -f4)
            success_rate=$(cat workflow-health-report/workflow-summary.json | grep -o '"success_rate":"[^"]*"' | cut -d'"' -f4)
            
            case $health_status in
              "excellent") echo "🟢 **Overall Health**: Excellent ($success_rate% success rate)" >> $GITHUB_STEP_SUMMARY ;;
              "good") echo "🟡 **Overall Health**: Good ($success_rate% success rate)" >> $GITHUB_STEP_SUMMARY ;;
              "warning") echo "🟠 **Overall Health**: Warning ($success_rate% success rate)" >> $GITHUB_STEP_SUMMARY ;;
              "critical") echo "🔴 **Overall Health**: Critical ($success_rate% success rate)" >> $GITHUB_STEP_SUMMARY ;;
            esac
          else
            echo "⚠️ **Health Report**: Not available" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### 📋 Available Reports" >> $GITHUB_STEP_SUMMARY
          echo "- Workflow health report and metrics" >> $GITHUB_STEP_SUMMARY
          echo "- Performance analysis and trends" >> $GITHUB_STEP_SUMMARY
          echo "- Interactive monitoring dashboard" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Check the workflow artifacts for detailed reports and dashboard files." >> $GITHUB_STEP_SUMMARY

      - name: Upload monitoring dashboard
        uses: actions/upload-artifact@v4
        with:
          name: monitoring-dashboard
          path: |
            dashboard.html
            **/*.md
            **/*.json