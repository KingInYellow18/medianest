#!/usr/bin/env node\n/**\n * üöÄ Build Performance Optimizer for MediaNest\n * \n * Optimizes build performance through:\n * - Bundle analysis and optimization\n * - Build cache management \n * - Dependency optimization\n * - Performance monitoring\n */\n\nconst fs = require('fs');\nconst path = require('path');\nconst { execSync } = require('child_process');\nconst crypto = require('crypto');\n\nclass BuildPerformanceOptimizer {\n  constructor() {\n    this.projectRoot = process.cwd();\n    this.buildCache = path.join(this.projectRoot, '.build-cache');\n    this.performanceLog = path.join(this.projectRoot, 'performance.log');\n    this.optimizationTargets = {\n      bundleSize: 500, // KB\n      buildTime: 300,  // seconds\n      cacheHitRate: 80 // percentage\n    };\n  }\n\n  /**\n   * Run complete build optimization\n   */\n  async optimize() {\n    console.log('üöÄ Starting Build Performance Optimization...');\n    console.log('=' .repeat(50));\n    \n    try {\n      // 1. Analyze current performance\n      await this.analyzeCurrentPerformance();\n      \n      // 2. Optimize dependencies\n      await this.optimizeDependencies();\n      \n      // 3. Optimize build configuration\n      await this.optimizeBuildConfig();\n      \n      // 4. Setup build cache\n      await this.setupBuildCache();\n      \n      // 5. Run optimized build\n      await this.runOptimizedBuild();\n      \n      // 6. Analyze results\n      await this.analyzeResults();\n      \n      console.log('\\n‚úÖ Build optimization completed successfully!');\n      \n    } catch (error) {\n      console.error('‚ùå Build optimization failed:', error.message);\n      process.exit(1);\n    }\n  }\n\n  /**\n   * Analyze current build performance\n   */\n  async analyzeCurrentPerformance() {\n    console.log('üîç Analyzing current build performance...');\n    \n    const analysis = {\n      timestamp: new Date().toISOString(),\n      dependencySizes: {},\n      buildCacheStatus: {},\n      bundleAnalysis: {}\n    };\n    \n    // Check dependency sizes\n    const workspaces = ['', 'backend', 'frontend', 'shared'];\n    for (const workspace of workspaces) {\n      const nodeModulesPath = path.join(this.projectRoot, workspace, 'node_modules');\n      if (fs.existsSync(nodeModulesPath)) {\n        try {\n          const size = execSync(`du -sb \"${nodeModulesPath}\" | cut -f1`, { encoding: 'utf8' }).trim();\n          const sizeMB = Math.round(parseInt(size) / 1024 / 1024);\n          analysis.dependencySizes[workspace || 'root'] = sizeMB;\n          console.log(`  üì¶ ${workspace || 'root'} dependencies: ${sizeMB}MB`);\n        } catch (err) {\n          console.log(`  ‚ö†Ô∏è Could not analyze ${workspace || 'root'} dependencies`);\n        }\n      }\n    }\n    \n    // Check build cache\n    if (fs.existsSync(this.buildCache)) {\n      const cacheSize = execSync(`du -sb \"${this.buildCache}\" | cut -f1`, { encoding: 'utf8' }).trim();\n      analysis.buildCacheStatus.size = Math.round(parseInt(cacheSize) / 1024 / 1024);\n      console.log(`  üíæ Build cache size: ${analysis.buildCacheStatus.size}MB`);\n    } else {\n      console.log('  üíæ No build cache found');\n    }\n    \n    // Check existing bundle sizes\n    const frontendBuild = path.join(this.projectRoot, 'frontend', '.next');\n    if (fs.existsSync(frontendBuild)) {\n      try {\n        const bundleSize = execSync(`find \"${frontendBuild}/static\" -name \"*.js\" -exec du -cb {} + | tail -1 | cut -f1`, { encoding: 'utf8' }).trim();\n        analysis.bundleAnalysis.currentSize = Math.round(parseInt(bundleSize) / 1024);\n        console.log(`  üìä Current bundle size: ${analysis.bundleAnalysis.currentSize}KB`);\n      } catch (err) {\n        console.log('  üìä No existing bundle to analyze');\n      }\n    }\n    \n    // Save analysis\n    this.saveAnalysis(analysis);\n    \n    return analysis;\n  }\n\n  /**\n   * Optimize dependencies\n   */\n  async optimizeDependencies() {\n    console.log('\\nüì¶ Optimizing dependencies...');\n    \n    // Clean npm cache\n    console.log('  üßπ Cleaning npm cache...');\n    execSync('npm cache clean --force', { stdio: 'pipe' });\n    \n    // Check for unused dependencies\n    console.log('  üîç Checking for optimization opportunities...');\n    \n    const packageJsonPath = path.join(this.projectRoot, 'package.json');\n    const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));\n    \n    // Suggest optimizations\n    const suggestions = [];\n    \n    // Check for large dependencies that could be optimized\n    const heavyDependencies = [\n      '@types/node',\n      'typescript',\n      'eslint',\n      'prettier'\n    ];\n    \n    for (const dep of heavyDependencies) {\n      if (packageJson.dependencies?.[dep]) {\n        suggestions.push(`Consider moving ${dep} to devDependencies`);\n      }\n    }\n    \n    if (suggestions.length > 0) {\n      console.log('  üí° Optimization suggestions:');\n      suggestions.forEach(suggestion => console.log(`    - ${suggestion}`));\n    } else {\n      console.log('  ‚úÖ Dependencies already optimized');\n    }\n  }\n\n  /**\n   * Optimize build configuration\n   */\n  async optimizeBuildConfig() {\n    console.log('\\nüîß Optimizing build configuration...');\n    \n    // Check Next.js config optimization\n    const nextConfigPath = path.join(this.projectRoot, 'frontend', 'next.config.js');\n    const optimizedConfigPath = path.join(this.projectRoot, 'frontend', 'next.config.optimized.js');\n    \n    if (fs.existsSync(optimizedConfigPath)) {\n      console.log('  ‚úÖ Optimized Next.js configuration available');\n      \n      // Backup current config if not already backed up\n      const backupPath = path.join(this.projectRoot, 'frontend', 'next.config.js.backup-pre-perf-optimization');\n      if (fs.existsSync(nextConfigPath) && !fs.existsSync(backupPath)) {\n        fs.copyFileSync(nextConfigPath, backupPath);\n        console.log('  üìã Current config backed up');\n      }\n      \n      // Use optimized config\n      fs.copyFileSync(optimizedConfigPath, nextConfigPath);\n      console.log('  üöÄ Switched to optimized configuration');\n    }\n    \n    // Check TypeScript configuration\n    const tsconfigPath = path.join(this.projectRoot, 'frontend', 'tsconfig.json');\n    if (fs.existsSync(tsconfigPath)) {\n      const tsconfig = JSON.parse(fs.readFileSync(tsconfigPath, 'utf8'));\n      \n      // Ensure optimal TypeScript settings\n      const optimalSettings = {\n        'incremental': true,\n        'skipLibCheck': true,\n        'strict': true,\n        'noEmit': true,\n        'isolatedModules': true\n      };\n      \n      let modified = false;\n      for (const [key, value] of Object.entries(optimalSettings)) {\n        if (tsconfig.compilerOptions?.[key] !== value) {\n          if (!tsconfig.compilerOptions) tsconfig.compilerOptions = {};\n          tsconfig.compilerOptions[key] = value;\n          modified = true;\n        }\n      }\n      \n      if (modified) {\n        fs.writeFileSync(tsconfigPath, JSON.stringify(tsconfig, null, 2));\n        console.log('  ‚öôÔ∏è TypeScript configuration optimized');\n      } else {\n        console.log('  ‚úÖ TypeScript configuration already optimal');\n      }\n    }\n  }\n\n  /**\n   * Setup build cache\n   */\n  async setupBuildCache() {\n    console.log('\\nüíæ Setting up build cache...');\n    \n    // Create build cache directory\n    if (!fs.existsSync(this.buildCache)) {\n      fs.mkdirSync(this.buildCache, { recursive: true });\n      console.log('  üìÅ Build cache directory created');\n    }\n    \n    // Setup cache structure\n    const cacheStructure = {\n      'dependencies': {},\n      'builds': {},\n      'analysis': {},\n      'metadata': {\n        created: new Date().toISOString(),\n        version: '1.0.0'\n      }\n    };\n    \n    const cacheIndexPath = path.join(this.buildCache, 'index.json');\n    if (!fs.existsSync(cacheIndexPath)) {\n      fs.writeFileSync(cacheIndexPath, JSON.stringify(cacheStructure, null, 2));\n      console.log('  üìù Cache index initialized');\n    }\n    \n    // Generate cache keys for current state\n    const packageLockFiles = [\n      'package-lock.json',\n      'backend/package-lock.json',\n      'frontend/package-lock.json',\n      'shared/package-lock.json'\n    ];\n    \n    const cacheKey = this.generateCacheKey(packageLockFiles);\n    console.log(`  üîë Generated cache key: ${cacheKey}`);\n    \n    return cacheKey;\n  }\n\n  /**\n   * Run optimized build\n   */\n  async runOptimizedBuild() {\n    console.log('\\nüèóÔ∏è Running optimized build...');\n    \n    const startTime = Date.now();\n    \n    try {\n      // Build backend\n      console.log('  üîß Building backend...');\n      const backendStart = Date.now();\n      execSync('cd backend && npm run build', { stdio: 'pipe' });\n      const backendTime = Date.now() - backendStart;\n      console.log(`  ‚úÖ Backend built in ${(backendTime / 1000).toFixed(1)}s`);\n      \n      // Build frontend  \n      console.log('  üé® Building frontend...');\n      const frontendStart = Date.now();\n      execSync('cd frontend && npm run build', { stdio: 'pipe' });\n      const frontendTime = Date.now() - frontendStart;\n      console.log(`  ‚úÖ Frontend built in ${(frontendTime / 1000).toFixed(1)}s`);\n      \n      const totalTime = Date.now() - startTime;\n      console.log(`\\n  üéØ Total build time: ${(totalTime / 1000).toFixed(1)}s`);\n      \n      // Check against target\n      if (totalTime / 1000 <= this.optimizationTargets.buildTime) {\n        console.log(`  ‚úÖ Build time target achieved (<${this.optimizationTargets.buildTime}s)`);\n      } else {\n        console.log(`  ‚ö†Ô∏è Build time exceeds target (${(totalTime / 1000).toFixed(1)}s > ${this.optimizationTargets.buildTime}s)`);\n      }\n      \n      return { totalTime, backendTime, frontendTime };\n      \n    } catch (error) {\n      console.error('‚ùå Build failed:', error.message);\n      throw error;\n    }\n  }\n\n  /**\n   * Analyze build results\n   */\n  async analyzeResults() {\n    console.log('\\nüìä Analyzing build results...');\n    \n    const results = {\n      bundleSize: null,\n      optimization: {},\n      recommendations: []\n    };\n    \n    // Analyze frontend bundle\n    const frontendBuild = path.join(this.projectRoot, 'frontend', '.next');\n    if (fs.existsSync(frontendBuild)) {\n      try {\n        // Calculate bundle size\n        const staticDir = path.join(frontendBuild, 'static');\n        if (fs.existsSync(staticDir)) {\n          const bundleSize = execSync(`find \"${staticDir}\" -name \"*.js\" -exec du -cb {} + | tail -1 | cut -f1`, { encoding: 'utf8' }).trim();\n          results.bundleSize = Math.round(parseInt(bundleSize) / 1024);\n          \n          console.log(`  üì¶ Bundle size: ${results.bundleSize}KB`);\n          \n          if (results.bundleSize <= this.optimizationTargets.bundleSize) {\n            console.log(`  ‚úÖ Bundle size target achieved (<${this.optimizationTargets.bundleSize}KB)`);\n          } else {\n            console.log(`  ‚ö†Ô∏è Bundle size exceeds target (${results.bundleSize}KB > ${this.optimizationTargets.bundleSize}KB)`);\n            results.recommendations.push('Consider implementing more aggressive code splitting');\n            results.recommendations.push('Review and optimize large dependencies');\n          }\n          \n          // Analyze chunk distribution\n          const chunkFiles = execSync(`find \"${staticDir}\" -name \"*.js\" | wc -l`, { encoding: 'utf8' }).trim();\n          console.log(`  üìÇ Number of chunks: ${chunkFiles}`);\n          \n          // Find largest chunks\n          const largestChunks = execSync(`find \"${staticDir}\" -name \"*.js\" -exec du -h {} + | sort -hr | head -5`, { encoding: 'utf8' });\n          console.log('  üìà Largest chunks:');\n          largestChunks.trim().split('\\n').forEach(chunk => {\n            console.log(`    ${chunk}`);\n          });\n        }\n      } catch (err) {\n        console.log('  ‚ö†Ô∏è Could not analyze bundle size');\n      }\n    }\n    \n    // Performance summary\n    console.log('\\nüéØ OPTIMIZATION SUMMARY:');\n    console.log('=' .repeat(30));\n    \n    if (results.bundleSize) {\n      const bundleOptimal = results.bundleSize <= this.optimizationTargets.bundleSize;\n      console.log(`Bundle Size: ${results.bundleSize}KB ${bundleOptimal ? '‚úÖ' : '‚ùå'}`);\n    }\n    \n    if (results.recommendations.length > 0) {\n      console.log('\\nüí° Recommendations:');\n      results.recommendations.forEach(rec => console.log(`  - ${rec}`));\n    }\n    \n    // Save results\n    this.saveResults(results);\n    \n    return results;\n  }\n\n  /**\n   * Generate cache key from files\n   */\n  generateCacheKey(files) {\n    const hash = crypto.createHash('sha256');\n    \n    files.forEach(file => {\n      const filePath = path.join(this.projectRoot, file);\n      if (fs.existsSync(filePath)) {\n        const content = fs.readFileSync(filePath);\n        hash.update(content);\n      }\n    });\n    \n    return hash.digest('hex').substring(0, 12);\n  }\n\n  /**\n   * Save analysis data\n   */\n  saveAnalysis(analysis) {\n    const analysisPath = path.join(this.buildCache || '.', 'analysis.json');\n    fs.writeFileSync(analysisPath, JSON.stringify(analysis, null, 2));\n  }\n\n  /**\n   * Save results\n   */\n  saveResults(results) {\n    const resultsPath = path.join(this.buildCache || '.', 'results.json');\n    const timestamp = new Date().toISOString();\n    \n    let allResults = [];\n    if (fs.existsSync(resultsPath)) {\n      allResults = JSON.parse(fs.readFileSync(resultsPath, 'utf8'));\n    }\n    \n    allResults.push({ timestamp, ...results });\n    \n    // Keep only last 10 results\n    if (allResults.length > 10) {\n      allResults = allResults.slice(-10);\n    }\n    \n    fs.writeFileSync(resultsPath, JSON.stringify(allResults, null, 2));\n  }\n\n  /**\n   * Clean build cache\n   */\n  async cleanCache() {\n    console.log('üßπ Cleaning build cache...');\n    \n    if (fs.existsSync(this.buildCache)) {\n      execSync(`rm -rf \"${this.buildCache}\"`);\n      console.log('‚úÖ Build cache cleaned');\n    }\n    \n    // Clean other build artifacts\n    const cleanPaths = [\n      'frontend/.next',\n      'backend/dist',\n      'node_modules/.cache',\n      '**/node_modules/.cache'\n    ];\n    \n    cleanPaths.forEach(cleanPath => {\n      try {\n        execSync(`find . -path \"${cleanPath}\" -exec rm -rf {} + 2>/dev/null || true`);\n      } catch (err) {\n        // Ignore errors\n      }\n    });\n    \n    console.log('‚úÖ Build artifacts cleaned');\n  }\n}\n\n// CLI interface\nif (require.main === module) {\n  const optimizer = new BuildPerformanceOptimizer();\n  \n  const command = process.argv[2];\n  \n  switch (command) {\n    case 'optimize':\n      optimizer.optimize();\n      break;\n    case 'analyze':\n      optimizer.analyzeCurrentPerformance();\n      break;\n    case 'clean':\n      optimizer.cleanCache();\n      break;\n    case 'help':\n    default:\n      console.log('üöÄ Build Performance Optimizer');\n      console.log('');\n      console.log('Usage:');\n      console.log('  node build-performance-enhancer.js <command>');\n      console.log('');\n      console.log('Commands:');\n      console.log('  optimize  - Run complete build optimization');\n      console.log('  analyze   - Analyze current build performance');\n      console.log('  clean     - Clean build cache and artifacts');\n      console.log('  help      - Show this help');\n      break;\n  }\n}\n\nmodule.exports = BuildPerformanceOptimizer;\n"