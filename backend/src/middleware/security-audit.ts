import { Request, Response, NextFunction } from 'express';\nimport fs from 'fs/promises';\nimport path from 'path';\nimport { logger } from '../utils/logger';\nimport { logSecurityEvent } from '../utils/security';\n\ninterface SecurityEvent {\n  id: string;\n  timestamp: string;\n  level: 'info' | 'warn' | 'error' | 'critical';\n  category: 'authentication' | 'authorization' | 'data_access' | 'system' | 'user_action';\n  event: string;\n  userId?: string;\n  sessionId?: string;\n  ipAddress: string;\n  userAgent: string;\n  resource?: string;\n  action?: string;\n  outcome: 'success' | 'failure' | 'blocked';\n  riskScore?: number;\n  details: Record<string, any>;\n  correlationId?: string;\n}\n\ninterface AuditConfig {\n  logFile?: string;\n  maxFileSize?: number; // bytes\n  maxFiles?: number;\n  logToConsole?: boolean;\n  logToFile?: boolean;\n  logToDatabase?: boolean;\n  sensitiveFields?: string[];\n}\n\nclass SecurityAuditLogger {\n  private config: AuditConfig;\n  private logBuffer: SecurityEvent[] = [];\n  private bufferSize = 100;\n  private flushInterval = 30000; // 30 seconds\n\n  constructor(config: AuditConfig = {}) {\n    this.config = {\n      logFile: path.join(process.cwd(), 'logs', 'security-audit.log'),\n      maxFileSize: 10 * 1024 * 1024, // 10MB\n      maxFiles: 10,\n      logToConsole: process.env.NODE_ENV !== 'production',\n      logToFile: true,\n      logToDatabase: false,\n      sensitiveFields: ['password', 'token', 'secret', 'key', 'hash'],\n      ...config\n    };\n\n    // Flush buffer periodically\n    setInterval(() => this.flushBuffer(), this.flushInterval);\n    \n    // Ensure log directory exists\n    this.ensureLogDirectory();\n  }\n\n  /**\n   * Log security event\n   */\n  async logEvent(event: Partial<SecurityEvent>): Promise<void> {\n    const fullEvent: SecurityEvent = {\n      id: this.generateEventId(),\n      timestamp: new Date().toISOString(),\n      level: event.level || 'info',\n      category: event.category || 'system',\n      event: event.event || 'unknown',\n      userId: event.userId,\n      sessionId: event.sessionId,\n      ipAddress: event.ipAddress || '',\n      userAgent: event.userAgent || '',\n      resource: event.resource,\n      action: event.action,\n      outcome: event.outcome || 'success',\n      riskScore: event.riskScore,\n      details: this.sanitizeDetails(event.details || {}),\n      correlationId: event.correlationId\n    };\n\n    // Add to buffer\n    this.logBuffer.push(fullEvent);\n\n    // Console logging\n    if (this.config.logToConsole) {\n      this.logToConsole(fullEvent);\n    }\n\n    // Immediate flush for critical events\n    if (fullEvent.level === 'critical' || this.logBuffer.length >= this.bufferSize) {\n      await this.flushBuffer();\n    }\n  }\n\n  /**\n   * Flush buffer to persistent storage\n   */\n  private async flushBuffer(): Promise<void> {\n    if (this.logBuffer.length === 0) return;\n\n    const events = [...this.logBuffer];\n    this.logBuffer = [];\n\n    try {\n      // File logging\n      if (this.config.logToFile) {\n        await this.logToFile(events);\n      }\n\n      // Database logging\n      if (this.config.logToDatabase) {\n        await this.logToDatabase(events);\n      }\n    } catch (error) {\n      logger.error('Failed to flush security audit buffer', { error, eventsCount: events.length });\n      \n      // Re-add events to buffer if logging fails\n      this.logBuffer.unshift(...events);\n    }\n  }\n\n  /**\n   * Log to console\n   */\n  private logToConsole(event: SecurityEvent): void {\n    const logMessage = `[SECURITY AUDIT] ${event.level.toUpperCase()} - ${event.category}:${event.event}`;\n    const logData = {\n      id: event.id,\n      timestamp: event.timestamp,\n      userId: event.userId,\n      ipAddress: event.ipAddress,\n      outcome: event.outcome,\n      details: event.details\n    };\n\n    switch (event.level) {\n      case 'critical':\n      case 'error':\n        console.error(logMessage, logData);\n        break;\n      case 'warn':\n        console.warn(logMessage, logData);\n        break;\n      default:\n        console.log(logMessage, logData);\n    }\n  }\n\n  /**\n   * Log to file\n   */\n  private async logToFile(events: SecurityEvent[]): Promise<void> {\n    if (!this.config.logFile) return;\n\n    const logEntries = events.map(event => JSON.stringify(event)).join('\\n') + '\\n';\n    \n    try {\n      // Check file size and rotate if needed\n      await this.rotateLogFileIfNeeded();\n      \n      // Append to log file\n      await fs.appendFile(this.config.logFile, logEntries, 'utf8');\n    } catch (error) {\n      logger.error('Failed to write security audit log to file', { \n        error, \n        logFile: this.config.logFile,\n        eventsCount: events.length \n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Log to database (placeholder)\n   */\n  private async logToDatabase(events: SecurityEvent[]): Promise<void> {\n    // TODO: Implement database logging\n    logger.info('Database logging not implemented', { eventsCount: events.length });\n  }\n\n  /**\n   * Rotate log file if needed\n   */\n  private async rotateLogFileIfNeeded(): Promise<void> {\n    if (!this.config.logFile || !this.config.maxFileSize) return;\n\n    try {\n      const stats = await fs.stat(this.config.logFile);\n      if (stats.size >= this.config.maxFileSize) {\n        await this.rotateLogFile();\n      }\n    } catch (error) {\n      // File doesn't exist yet, which is fine\n      if ((error as any).code !== 'ENOENT') {\n        logger.warn('Error checking log file size', { error, logFile: this.config.logFile });\n      }\n    }\n  }\n\n  /**\n   * Rotate log file\n   */\n  private async rotateLogFile(): Promise<void> {\n    if (!this.config.logFile || !this.config.maxFiles) return;\n\n    const logDir = path.dirname(this.config.logFile);\n    const logName = path.basename(this.config.logFile, '.log');\n    \n    try {\n      // Rotate existing files\n      for (let i = this.config.maxFiles - 1; i > 0; i--) {\n        const currentFile = path.join(logDir, `${logName}.${i}.log`);\n        const nextFile = path.join(logDir, `${logName}.${i + 1}.log`);\n        \n        try {\n          await fs.access(currentFile);\n          if (i === this.config.maxFiles - 1) {\n            await fs.unlink(currentFile); // Delete oldest file\n          } else {\n            await fs.rename(currentFile, nextFile);\n          }\n        } catch {\n          // File doesn't exist, skip\n        }\n      }\n      \n      // Rename current log file\n      const rotatedFile = path.join(logDir, `${logName}.1.log`);\n      await fs.rename(this.config.logFile, rotatedFile);\n      \n      logger.info('Security audit log file rotated', {\n        originalFile: this.config.logFile,\n        rotatedFile\n      });\n    } catch (error) {\n      logger.error('Failed to rotate security audit log file', { error, logFile: this.config.logFile });\n      throw error;\n    }\n  }\n\n  /**\n   * Ensure log directory exists\n   */\n  private async ensureLogDirectory(): Promise<void> {\n    if (!this.config.logFile) return;\n    \n    const logDir = path.dirname(this.config.logFile);\n    \n    try {\n      await fs.access(logDir);\n    } catch {\n      try {\n        await fs.mkdir(logDir, { recursive: true });\n        logger.info('Created security audit log directory', { logDir });\n      } catch (error) {\n        logger.error('Failed to create log directory', { error, logDir });\n      }\n    }\n  }\n\n  /**\n   * Generate unique event ID\n   */\n  private generateEventId(): string {\n    return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  /**\n   * Sanitize sensitive details\n   */\n  private sanitizeDetails(details: Record<string, any>): Record<string, any> {\n    const sanitized = { ...details };\n    \n    const sanitizeValue = (obj: any, key: string): any => {\n      if (this.config.sensitiveFields?.some(field => \n        key.toLowerCase().includes(field.toLowerCase())\n      )) {\n        return '[REDACTED]';\n      }\n      return obj;\n    };\n\n    const sanitizeObject = (obj: any): any => {\n      if (obj === null || obj === undefined) return obj;\n      \n      if (Array.isArray(obj)) {\n        return obj.map(sanitizeObject);\n      }\n      \n      if (typeof obj === 'object') {\n        const result: any = {};\n        for (const [key, value] of Object.entries(obj)) {\n          result[key] = sanitizeValue(sanitizeObject(value), key);\n        }\n        return result;\n      }\n      \n      return obj;\n    };\n\n    return sanitizeObject(sanitized);\n  }\n\n  /**\n   * Search audit logs\n   */\n  async searchLogs(criteria: {\n    startDate?: Date;\n    endDate?: Date;\n    userId?: string;\n    ipAddress?: string;\n    category?: string;\n    event?: string;\n    level?: string;\n    limit?: number;\n  }): Promise<SecurityEvent[]> {\n    // TODO: Implement log search functionality\n    // This would typically query a database or parse log files\n    logger.info('Log search not implemented', { criteria });\n    return [];\n  }\n\n  /**\n   * Get audit statistics\n   */\n  async getStatistics(timeRange: { start: Date; end: Date }): Promise<{\n    totalEvents: number;\n    eventsByCategory: Record<string, number>;\n    eventsByLevel: Record<string, number>;\n    topUsers: Array<{ userId: string; eventCount: number }>;\n    topIPs: Array<{ ipAddress: string; eventCount: number }>;\n  }> {\n    // TODO: Implement statistics functionality\n    logger.info('Statistics not implemented', { timeRange });\n    return {\n      totalEvents: 0,\n      eventsByCategory: {},\n      eventsByLevel: {},\n      topUsers: [],\n      topIPs: []\n    };\n  }\n}\n\n// Global audit logger instance\nconst auditLogger = new SecurityAuditLogger();\n\n/**\n * Security audit middleware\n */\nexport function securityAuditMiddleware() {\n  return (req: Request, res: Response, next: NextFunction) => {\n    const startTime = Date.now();\n    \n    // Capture original res.json and res.status\n    const originalJson = res.json.bind(res);\n    const originalStatus = res.status.bind(res);\n    \n    let statusCode = 200;\n    let responseBody: any;\n    \n    // Override res.status to capture status code\n    res.status = function(code: number) {\n      statusCode = code;\n      return originalStatus(code);\n    };\n    \n    // Override res.json to capture response\n    res.json = function(body: any) {\n      responseBody = body;\n      return originalJson(body);\n    };\n    \n    // Log the request when response finishes\n    res.on('finish', async () => {\n      const duration = Date.now() - startTime;\n      const outcome = statusCode < 400 ? 'success' : \n                     statusCode < 500 ? 'failure' : 'error';\n      \n      // Determine category based on path\n      let category: SecurityEvent['category'] = 'system';\n      if (req.path.includes('/auth/')) {\n        category = statusCode === 401 || statusCode === 403 ? 'authorization' : 'authentication';\n      } else if (req.method !== 'GET') {\n        category = 'data_access';\n      } else {\n        category = 'user_action';\n      }\n      \n      // Calculate basic risk score\n      let riskScore = 0;\n      if (statusCode === 401) riskScore += 20;\n      if (statusCode === 403) riskScore += 30;\n      if (statusCode >= 500) riskScore += 10;\n      if (req.method === 'DELETE') riskScore += 15;\n      if (req.path.includes('/admin/')) riskScore += 25;\n      \n      const event: Partial<SecurityEvent> = {\n        level: statusCode >= 500 ? 'error' : \n               statusCode >= 400 ? 'warn' : 'info',\n        category,\n        event: `${req.method} ${req.path}`,\n        userId: req.user?.id,\n        sessionId: req.sessionID,\n        ipAddress: req.ip || req.connection.remoteAddress || '',\n        userAgent: req.get('user-agent') || '',\n        resource: req.path,\n        action: req.method,\n        outcome,\n        riskScore,\n        details: {\n          statusCode,\n          duration,\n          contentLength: res.get('content-length'),\n          query: req.query,\n          params: req.params,\n          referer: req.get('referer'),\n          origin: req.get('origin'),\n          ...(statusCode >= 400 && responseBody ? { error: responseBody } : {})\n        },\n        correlationId: req.correlationId\n      };\n      \n      try {\n        await auditLogger.logEvent(event);\n      } catch (error) {\n        logger.error('Failed to log security audit event', { error, event });\n      }\n    });\n    \n    next();\n  };\n}\n\n/**\n * Log authentication events\n */\nexport function logAuthEvent(\n  event: string,\n  req: Request,\n  outcome: 'success' | 'failure' | 'blocked',\n  details: Record<string, any> = {}\n): void {\n  auditLogger.logEvent({\n    level: outcome === 'success' ? 'info' : 'warn',\n    category: 'authentication',\n    event,\n    userId: req.user?.id,\n    sessionId: req.sessionID,\n    ipAddress: req.ip || req.connection.remoteAddress || '',\n    userAgent: req.get('user-agent') || '',\n    outcome,\n    details: {\n      path: req.path,\n      method: req.method,\n      ...details\n    },\n    correlationId: req.correlationId\n  });\n}\n\n/**\n * Log authorization events\n */\nexport function logAuthzEvent(\n  event: string,\n  req: Request,\n  resource: string,\n  outcome: 'success' | 'failure' | 'blocked',\n  details: Record<string, any> = {}\n): void {\n  auditLogger.logEvent({\n    level: outcome === 'blocked' ? 'warn' : 'info',\n    category: 'authorization',\n    event,\n    userId: req.user?.id,\n    sessionId: req.sessionID,\n    ipAddress: req.ip || req.connection.remoteAddress || '',\n    userAgent: req.get('user-agent') || '',\n    resource,\n    action: req.method,\n    outcome,\n    details,\n    correlationId: req.correlationId\n  });\n}\n\n/**\n * Log data access events\n */\nexport function logDataAccessEvent(\n  event: string,\n  req: Request,\n  resource: string,\n  action: string,\n  outcome: 'success' | 'failure' | 'blocked',\n  details: Record<string, any> = {}\n): void {\n  auditLogger.logEvent({\n    level: 'info',\n    category: 'data_access',\n    event,\n    userId: req.user?.id,\n    sessionId: req.sessionID,\n    ipAddress: req.ip || req.connection.remoteAddress || '',\n    userAgent: req.get('user-agent') || '',\n    resource,\n    action,\n    outcome,\n    details,\n    correlationId: req.correlationId\n  });\n}\n\n/**\n * Log critical security events\n */\nexport function logCriticalSecurityEvent(\n  event: string,\n  details: Record<string, any>,\n  req?: Request\n): void {\n  auditLogger.logEvent({\n    level: 'critical',\n    category: 'system',\n    event,\n    userId: req?.user?.id,\n    sessionId: req?.sessionID,\n    ipAddress: req?.ip || req?.connection.remoteAddress || '',\n    userAgent: req?.get('user-agent') || '',\n    outcome: 'blocked',\n    riskScore: 100,\n    details,\n    correlationId: req?.correlationId\n  });\n}\n\n// Export the audit logger instance for direct use\nexport { auditLogger as SecurityAuditLogger };\n\n// Export audit log search and statistics functions\nexport const auditLogSearch = auditLogger.searchLogs.bind(auditLogger);\nexport const auditLogStatistics = auditLogger.getStatistics.bind(auditLogger);