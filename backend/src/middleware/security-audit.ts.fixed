import { Request, Response, NextFunction } from 'express'

import fs from 'fs/promises'

import path from 'path'

import { logger } from '../utils/logger'

import { logSecurityEvent } from '../utils/security'


interface SecurityEvent {
  id: string

  timestamp: string

  level: 'info' | 'warn' | 'error' | 'critical'

  category: 'authentication' | 'authorization' | 'data_access' | 'system' | 'user_action'

  event: string

  userId?: string

  sessionId?: string

  ipAddress: string

  userAgent: string

  resource?: string

  action?: string

  outcome: 'success' | 'failure' | 'blocked'

  riskScore?: number

  details: Record<string, any>

  correlationId?: string

}

interface AuditConfig {
  logFile?: string

  maxFileSize?: number
 // bytes
  maxFiles?: number

  logToConsole?: boolean

  logToFile?: boolean

  logToDatabase?: boolean

  sensitiveFields?: string[]

}

class SecurityAuditLogger {
  private config: AuditConfig

  private logBuffer: SecurityEvent[] = []

  private bufferSize = 100

  private flushInterval = 30000
 // 30 seconds

  constructor(config: AuditConfig = {}) {
    this.config = {
      logFile: path.join(process.cwd(), 'logs', 'security-audit.log'),
      maxFileSize: 10 * 1024 * 1024, // 10MB
      maxFiles: 10,
      logToConsole: process.env.NODE_ENV !== 'production',
      logToFile: true,
      logToDatabase: false,
      sensitiveFields: ['password', 'token', 'secret', 'key', 'hash'],
      ...config
    }


    // Flush buffer periodically
    setInterval(() => this.flushBuffer(), this.flushInterval)

    
    // Ensure log directory exists
    this.ensureLogDirectory()

  }

  /**
   * Log security event
   */
  async logEvent(event: Partial<SecurityEvent>): Promise<void> {
    const fullEvent: SecurityEvent = {
      id: this.generateEventId(),
      timestamp: new Date().toISOString(),
      level: event.level || 'info',
      category: event.category || 'system',
      event: event.event || 'unknown',
      userId: event.userId,
      sessionId: event.sessionId,
      ipAddress: event.ipAddress || '',
      userAgent: event.userAgent || '',
      resource: event.resource,
      action: event.action,
      outcome: event.outcome || 'success',
      riskScore: event.riskScore,
      details: this.sanitizeDetails(event.details || {}),
      correlationId: event.correlationId
    }


    // Add to buffer
    this.logBuffer.push(fullEvent)


    // Console logging
    if (this.config.logToConsole) {
      this.logToConsole(fullEvent)

    }

    // Immediate flush for critical events
    if (fullEvent.level === 'critical' || this.logBuffer.length >= this.bufferSize) {
      await this.flushBuffer()

    }
  }

  /**
   * Flush buffer to persistent storage
   */
  private async flushBuffer(): Promise<void> {
    if (this.logBuffer.length === 0) return


    const events = [...this.logBuffer]

    this.logBuffer = []


    try {
      // File logging
      if (this.config.logToFile) {
        await this.logToFile(events)

      }

      // Database logging
      if (this.config.logToDatabase) {
        await this.logToDatabase(events)

      }
    } catch (error) {
      logger.error('Failed to flush security audit buffer', { error, eventsCount: events.length })

      
      // Re-add events to buffer if logging fails
      this.logBuffer.unshift(...events)

    }
  }

  /**
   * Log to console
   */
  private logToConsole(event: SecurityEvent): void {
    const logMessage = `[SECURITY AUDIT] ${event.level.toUpperCase()} - ${event.category}:${event.event}`

    const logData = {
      id: event.id,
      timestamp: event.timestamp,
      userId: event.userId,
      ipAddress: event.ipAddress,
      outcome: event.outcome,
      details: event.details
    }


    switch (event.level) {
      case 'critical':
      case 'error':
        console.error(logMessage, logData)

        break

      case 'warn':
        console.warn(logMessage, logData)

        break

      default:
        console.log(logMessage, logData)

    }
  }

  /**
   * Log to file
   */
  private async logToFile(events: SecurityEvent[]): Promise<void> {
    if (!this.config.logFile) return


    const logEntries = events.map(event => JSON.stringify(event)).join('\
') + '\
'

    
    try {
      // Check file size and rotate if needed
      await this.rotateLogFileIfNeeded()

      
      // Append to log file
      await fs.appendFile(this.config.logFile, logEntries, 'utf8')

    } catch (error) {
      logger.error('Failed to write security audit log to file', { 
        error, 
        logFile: this.config.logFile,
        eventsCount: events.length 
      })

      throw error

    }
  }

  /**
   * Log to database (placeholder)
   */
  private async logToDatabase(events: SecurityEvent[]): Promise<void> {
    // TODO: Implement database logging
    logger.info('Database logging not implemented', { eventsCount: events.length })

  }

  /**
   * Rotate log file if needed
   */
  private async rotateLogFileIfNeeded(): Promise<void> {
    if (!this.config.logFile || !this.config.maxFileSize) return


    try {
      const stats = await fs.stat(this.config.logFile)

      if (stats.size >= this.config.maxFileSize) {
        await this.rotateLogFile()

      }
    } catch (error) {
      // File doesn't exist yet, which is fine
      if ((error as any).code !== 'ENOENT') {
        logger.warn('Error checking log file size', { error, logFile: this.config.logFile })

      }
    }
  }

  /**
   * Rotate log file
   */
  private async rotateLogFile(): Promise<void> {
    if (!this.config.logFile || !this.config.maxFiles) return


    const logDir = path.dirname(this.config.logFile)

    const logName = path.basename(this.config.logFile, '.log')

    
    try {
      // Rotate existing files
      for (let i = this.config.maxFiles - 1
 i > 0
 i--) {
        const currentFile = path.join(logDir, `${logName}.${i}.log`)

        const nextFile = path.join(logDir, `${logName}.${i + 1}.log`)

        
        try {
          await fs.access(currentFile)

          if (i === this.config.maxFiles - 1) {
            await fs.unlink(currentFile)
 // Delete oldest file
          } else {
            await fs.rename(currentFile, nextFile)

          }
        } catch {
          // File doesn't exist, skip
        }
      }
      
      // Rename current log file
      const rotatedFile = path.join(logDir, `${logName}.1.log`)

      await fs.rename(this.config.logFile, rotatedFile)

      
      logger.info('Security audit log file rotated', {
        originalFile: this.config.logFile,
        rotatedFile
      })

    } catch (error) {
      logger.error('Failed to rotate security audit log file', { error, logFile: this.config.logFile })

      throw error

    }
  }

  /**
   * Ensure log directory exists
   */
  private async ensureLogDirectory(): Promise<void> {
    if (!this.config.logFile) return

    
    const logDir = path.dirname(this.config.logFile)

    
    try {
      await fs.access(logDir)

    } catch {
      try {
        await fs.mkdir(logDir, { recursive: true })

        logger.info('Created security audit log directory', { logDir })

      } catch (error) {
        logger.error('Failed to create log directory', { error, logDir })

      }
    }
  }

  /**
   * Generate unique event ID
   */
  private generateEventId(): string {
    return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`

  }

  /**
   * Sanitize sensitive details
   */
  private sanitizeDetails(details: Record<string, any>): Record<string, any> {
    const sanitized = { ...details }

    
    const sanitizeValue = (obj: any, key: string): any => {
      if (this.config.sensitiveFields?.some(field => 
        key.toLowerCase().includes(field.toLowerCase())
      )) {
        return '[REDACTED]'

      }
      return obj

    }


    const sanitizeObject = (obj: any): any => {
      if (obj === null || obj === undefined) return obj

      
      if (Array.isArray(obj)) {
        return obj.map(sanitizeObject)

      }
      
      if (typeof obj === 'object') {
        const result: any = {}

        for (const [key, value] of Object.entries(obj)) {
          result[key] = sanitizeValue(sanitizeObject(value), key)

        }
        return result

      }
      
      return obj

    }


    return sanitizeObject(sanitized)

  }

  /**
   * Search audit logs
   */
  async searchLogs(criteria: {
    startDate?: Date

    endDate?: Date

    userId?: string

    ipAddress?: string

    category?: string

    event?: string

    level?: string

    limit?: number

  }): Promise<SecurityEvent[]> {
    // TODO: Implement log search functionality
    // This would typically query a database or parse log files
    logger.info('Log search not implemented', { criteria })

    return []

  }

  /**
   * Get audit statistics
   */
  async getStatistics(timeRange: { start: Date
 end: Date }): Promise<{
    totalEvents: number

    eventsByCategory: Record<string, number>

    eventsByLevel: Record<string, number>

    topUsers: Array<{ userId: string
 eventCount: number }>

    topIPs: Array<{ ipAddress: string
 eventCount: number }>

  }> {
    // TODO: Implement statistics functionality
    logger.info('Statistics not implemented', { timeRange })

    return {
      totalEvents: 0,
      eventsByCategory: {},
      eventsByLevel: {},
      topUsers: [],
      topIPs: []
    }

  }
}

// Global audit logger instance
const auditLogger = new SecurityAuditLogger()


/**
 * Security audit middleware
 */
export function securityAuditMiddleware() {
  return (req: Request, res: Response, next: NextFunction) => {
    const startTime = Date.now()

    
    // Capture original res.json and res.status
    const originalJson = res.json.bind(res)

    const originalStatus = res.status.bind(res)

    
    let statusCode = 200

    let responseBody: any

    
    // Override res.status to capture status code
    res.status = function(code: number) {
      statusCode = code

      return originalStatus(code)

    }

    
    // Override res.json to capture response
    res.json = function(body: any) {
      responseBody = body

      return originalJson(body)

    }

    
    // Log the request when response finishes
    res.on('finish', async () => {
      const duration = Date.now() - startTime

      const outcome = statusCode < 400 ? 'success' : 
                     statusCode < 500 ? 'failure' : 'error'

      
      // Determine category based on path
      let category: SecurityEvent['category'] = 'system'

      if (req.path.includes('/auth/')) {
        category = statusCode === 401 || statusCode === 403 ? 'authorization' : 'authentication'

      } else if (req.method !== 'GET') {
        category = 'data_access'

      } else {
        category = 'user_action'

      }
      
      // Calculate basic risk score
      let riskScore = 0

      if (statusCode === 401) riskScore += 20

      if (statusCode === 403) riskScore += 30

      if (statusCode >= 500) riskScore += 10

      if (req.method === 'DELETE') riskScore += 15

      if (req.path.includes('/admin/')) riskScore += 25

      
      const event: Partial<SecurityEvent> = {
        level: statusCode >= 500 ? 'error' : 
               statusCode >= 400 ? 'warn' : 'info',
        category,
        event: `${req.method} ${req.path}`,
        userId: req.user?.id,
        sessionId: req.sessionID,
        ipAddress: req.ip || req.connection.remoteAddress || '',
        userAgent: req.get('user-agent') || '',
        resource: req.path,
        action: req.method,
        outcome,
        riskScore,
        details: {
          statusCode,
          duration,
          contentLength: res.get('content-length'),
          query: req.query,
          params: req.params,
          referer: req.get('referer'),
          origin: req.get('origin'),
          ...(statusCode >= 400 && responseBody ? { error: responseBody } : {})
        },
        correlationId: req.correlationId
      }

      
      try {
        await auditLogger.logEvent(event)

      } catch (error) {
        logger.error('Failed to log security audit event', { error, event })

      }
    })

    
    next()

  }

}

/**
 * Log authentication events
 */
export function logAuthEvent(
  event: string,
  req: Request,
  outcome: 'success' | 'failure' | 'blocked',
  details: Record<string, any> = {}
): void {
  auditLogger.logEvent({
    level: outcome === 'success' ? 'info' : 'warn',
    category: 'authentication',
    event,
    userId: req.user?.id,
    sessionId: req.sessionID,
    ipAddress: req.ip || req.connection.remoteAddress || '',
    userAgent: req.get('user-agent') || '',
    outcome,
    details: {
      path: req.path,
      method: req.method,
      ...details
    },
    correlationId: req.correlationId
  })

}

/**
 * Log authorization events
 */
export function logAuthzEvent(
  event: string,
  req: Request,
  resource: string,
  outcome: 'success' | 'failure' | 'blocked',
  details: Record<string, any> = {}
): void {
  auditLogger.logEvent({
    level: outcome === 'blocked' ? 'warn' : 'info',
    category: 'authorization',
    event,
    userId: req.user?.id,
    sessionId: req.sessionID,
    ipAddress: req.ip || req.connection.remoteAddress || '',
    userAgent: req.get('user-agent') || '',
    resource,
    action: req.method,
    outcome,
    details,
    correlationId: req.correlationId
  })

}

/**
 * Log data access events
 */
export function logDataAccessEvent(
  event: string,
  req: Request,
  resource: string,
  action: string,
  outcome: 'success' | 'failure' | 'blocked',
  details: Record<string, any> = {}
): void {
  auditLogger.logEvent({
    level: 'info',
    category: 'data_access',
    event,
    userId: req.user?.id,
    sessionId: req.sessionID,
    ipAddress: req.ip || req.connection.remoteAddress || '',
    userAgent: req.get('user-agent') || '',
    resource,
    action,
    outcome,
    details,
    correlationId: req.correlationId
  })

}

/**
 * Log critical security events
 */
export function logCriticalSecurityEvent(
  event: string,
  details: Record<string, any>,
  req?: Request
): void {
  auditLogger.logEvent({
    level: 'critical',
    category: 'system',
    event,
    userId: req?.user?.id,
    sessionId: req?.sessionID,
    ipAddress: req?.ip || req?.connection.remoteAddress || '',
    userAgent: req?.get('user-agent') || '',
    outcome: 'blocked',
    riskScore: 100,
    details,
    correlationId: req?.correlationId
  })

}

// Export the audit logger instance for direct use
export { auditLogger as SecurityAuditLogger }


// Export audit log search and statistics functions
export const auditLogSearch = auditLogger.searchLogs.bind(auditLogger)

export const auditLogStatistics = auditLogger.getStatistics.bind(auditLogger)
