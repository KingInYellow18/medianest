import request from 'supertest';
import { createApp } from '@/app';
import { setupTestDatabase, cleanupTestDatabase } from '../helpers/database-helper';
import { createTestUser, createAuthToken } from '../helpers/auth-test-helper';
import { redisTestHelper } from '../helpers/redis-test-helper';
import { PlexClient } from '@/integrations/plex/plex.client';
import { YouTubeClient } from '@/integrations/youtube/youtube.client';
import { webhookIntegrationService } from '@/services/webhook-integration.service';

describe('External API Integration Tests', () => {
  let app: any;\n  let authToken: string;\n  let testUserId: string;\n\n  beforeAll(async () => {\n    await setupTestDatabase();\n    await redisTestHelper.connect();\n    \n    app = createApp();\n    \n    // Create test user and auth token\n    const testUser = await createTestUser({ isAdmin: true });\n    testUserId = testUser.id;\n    authToken = await createAuthToken(testUser);\n  });\n\n  afterAll(async () => {\n    await cleanupTestDatabase();\n    await redisTestHelper.disconnect();\n  });\n\n  beforeEach(async () => {\n    await redisTestHelper.flushAll();\n  });\n\n  describe('Plex Integration', () => {\n    const mockPlexResponse = {\n      MediaContainer: {\n        friendlyName: 'Test Plex Server',\n        machineIdentifier: 'test-machine-123',\n        version: '1.32.0',\n        platform: 'Linux',\n        updatedAt: 1640995200,\n        Directory: [\n          {\n            key: '1',\n            type: 'movie',\n            title: 'Movies',\n            uuid: 'movie-uuid-123',\n            updatedAt: 1640995200,\n          },\n          {\n            key: '2',\n            type: 'show',\n            title: 'TV Shows',\n            uuid: 'show-uuid-456',\n            updatedAt: 1640995200,\n          },\n        ],\n      },\n    };\n\n    describe('GET /api/plex/health', () => {\n      it('should return health status when Plex is available', async () => {\n        // Mock successful Plex connection\n        jest.spyOn(PlexClient.prototype, 'testConnection')\n          .mockResolvedValue({\n            name: 'Test Plex Server',\n            machineIdentifier: 'test-machine-123',\n            version: '1.32.0',\n            platform: 'Linux',\n            updatedAt: 1640995200,\n          });\n\n        const response = await request(app)\n          .get('/api/plex/health')\n          .set('Authorization', `Bearer ${authToken}`)\n          .expect(200);\n\n        expect(response.body).toMatchObject({\n          status: 'healthy',\n          server: 'Test Plex Server',\n          version: '1.32.0',\n        });\n      });\n\n      it('should return unhealthy status when Plex is unavailable', async () => {\n        // Mock failed Plex connection\n        jest.spyOn(PlexClient.prototype, 'testConnection')\n          .mockRejectedValue(new Error('Connection failed'));\n\n        const response = await request(app)\n          .get('/api/plex/health')\n          .set('Authorization', `Bearer ${authToken}`)\n          .expect(503);\n\n        expect(response.body).toMatchObject({\n          status: 'unhealthy',\n          error: 'Connection failed',\n        });\n      });\n    });\n\n    describe('GET /api/plex/libraries', () => {\n      it('should fetch and cache Plex libraries', async () => {\n        jest.spyOn(PlexClient.prototype, 'getLibraries')\n          .mockResolvedValue(mockPlexResponse.MediaContainer.Directory);\n\n        const response = await request(app)\n          .get('/api/plex/libraries')\n          .set('Authorization', `Bearer ${authToken}`)\n          .expect(200);\n\n        expect(response.body).toMatchObject({\n          success: true,\n          data: expect.arrayContaining([\n            expect.objectContaining({\n              key: '1',\n              type: 'movie',\n              title: 'Movies',\n            }),\n          ]),\n          meta: {\n            count: 2,\n          },\n        });\n\n        // Verify caching - second request should use cache\n        const secondResponse = await request(app)\n          .get('/api/plex/libraries')\n          .set('Authorization', `Bearer ${authToken}`)\n          .expect(200);\n\n        expect(secondResponse.body).toEqual(response.body);\n      });\n\n      it('should handle Plex connection failures gracefully', async () => {\n        jest.spyOn(PlexClient.prototype, 'getLibraries')\n          .mockRejectedValue(new Error('Plex server unreachable'));\n\n        await request(app)\n          .get('/api/plex/libraries')\n          .set('Authorization', `Bearer ${authToken}`)\n          .expect(503);\n      });\n    });\n\n    describe('GET /api/plex/libraries/:libraryKey/items', () => {\n      it('should fetch library items with pagination', async () => {\n        const mockItems = {\n          items: [\n            {\n              ratingKey: '1',\n              key: '/library/metadata/1',\n              guid: 'com.plexapp.agents.imdb://tt0111161',\n              type: 'movie',\n              title: 'The Shawshank Redemption',\n              year: 1994,\n              addedAt: 1640995200,\n            },\n          ],\n          totalSize: 100,\n        };\n\n        jest.spyOn(PlexClient.prototype, 'getLibraryItems')\n          .mockResolvedValue(mockItems);\n\n        const response = await request(app)\n          .get('/api/plex/libraries/1/items?offset=0&limit=20')\n          .set('Authorization', `Bearer ${authToken}`)\n          .expect(200);\n\n        expect(response.body).toMatchObject({\n          success: true,\n          data: mockItems.items,\n          meta: {\n            offset: 0,\n            limit: 20,\n            total: 100,\n          },\n        });\n      });\n\n      it('should validate pagination parameters', async () => {\n        await request(app)\n          .get('/api/plex/libraries/1/items?offset=-1&limit=0')\n          .set('Authorization', `Bearer ${authToken}`)\n          .expect(400);\n      });\n    });\n\n    describe('Rate Limiting', () => {\n      it('should enforce rate limits for Plex API calls', async () => {\n        jest.spyOn(PlexClient.prototype, 'getLibraries')\n          .mockResolvedValue([]);\n\n        // Make requests up to the limit\n        const requests = Array.from({ length: 101 }, (_, i) => \n          request(app)\n            .get('/api/plex/libraries')\n            .set('Authorization', `Bearer ${authToken}`)\n        );\n\n        const responses = await Promise.all(requests);\n        \n        // First 100 should succeed, 101st should be rate limited\n        expect(responses.slice(0, 100).every(r => r.status === 200)).toBe(true);\n        expect(responses[100].status).toBe(429);\n      });\n    });\n  });\n\n  describe('YouTube Integration', () => {\n    const mockVideoInfo = {\n      id: 'dQw4w9WgXcQ',\n      title: 'Test Video',\n      channel: 'Test Channel',\n      duration: 212,\n      thumbnail: 'https://img.youtube.com/vi/dQw4w9WgXcQ/maxresdefault.jpg',\n      description: 'Test video description',\n      uploadDate: '20220101',\n      viewCount: 1000000,\n      formats: [\n        {\n          formatId: '137',\n          ext: 'mp4',\n          quality: '1080p',\n          height: 1080,\n          width: 1920,\n          filesize: 50000000,\n        },\n      ],\n    };\n\n    describe('GET /api/youtube/health', () => {\n      it('should return healthy status when yt-dlp is available', async () => {\n        jest.spyOn(YouTubeClient.prototype, 'checkAvailability')\n          .mockResolvedValue(true);\n\n        const response = await request(app)\n          .get('/api/youtube/health')\n          .expect(200);\n\n        expect(response.body).toMatchObject({\n          status: 'healthy',\n          service: 'YouTube Download Service',\n          ytDlpAvailable: true,\n          features: {\n            download: true,\n            metadata: true,\n            rateLimiting: true,\n            queueing: true,\n          },\n        });\n      });\n\n      it('should return degraded status when yt-dlp is unavailable', async () => {\n        jest.spyOn(YouTubeClient.prototype, 'checkAvailability')\n          .mockResolvedValue(false);\n\n        const response = await request(app)\n          .get('/api/youtube/health')\n          .expect(200);\n\n        expect(response.body.status).toBe('degraded');\n        expect(response.body.ytDlpAvailable).toBe(false);\n      });\n    });\n\n    describe('GET /api/youtube/metadata', () => {\n      it('should fetch video metadata with caching', async () => {\n        jest.spyOn(YouTubeClient.prototype, 'getVideoInfo')\n          .mockResolvedValue(mockVideoInfo);\n\n        const response = await request(app)\n          .get('/api/youtube/metadata?url=https://www.youtube.com/watch?v=dQw4w9WgXcQ')\n          .set('Authorization', `Bearer ${authToken}`)\n          .expect(200);\n\n        expect(response.body).toMatchObject({\n          id: 'dQw4w9WgXcQ',\n          title: 'Test Video',\n          channel: 'Test Channel',\n          duration: 212,\n          availableQualities: ['1080p'],\n        });\n\n        // Verify caching works\n        const cachedResponse = await request(app)\n          .get('/api/youtube/metadata?url=https://www.youtube.com/watch?v=dQw4w9WgXcQ')\n          .set('Authorization', `Bearer ${authToken}`)\n          .expect(200);\n\n        expect(cachedResponse.body).toEqual(response.body);\n      });\n\n      it('should validate YouTube URL format', async () => {\n        await request(app)\n          .get('/api/youtube/metadata?url=https://invalid-url.com/video')\n          .set('Authorization', `Bearer ${authToken}`)\n          .expect(400);\n      });\n\n      it('should handle YouTube API errors', async () => {\n        jest.spyOn(YouTubeClient.prototype, 'getVideoInfo')\n          .mockRejectedValue(new Error('Video not found'));\n\n        const response = await request(app)\n          .get('/api/youtube/metadata?url=https://www.youtube.com/watch?v=invalid')\n          .set('Authorization', `Bearer ${authToken}`)\n          .expect(400);\n\n        expect(response.body.error).toContain('Video not found');\n      });\n    });\n\n    describe('POST /api/youtube/download', () => {\n      it('should create download job with proper validation', async () => {\n        jest.spyOn(YouTubeClient.prototype, 'getVideoInfo')\n          .mockResolvedValue(mockVideoInfo);\n\n        const response = await request(app)\n          .post('/api/youtube/download')\n          .set('Authorization', `Bearer ${authToken}`)\n          .send({\n            url: 'https://www.youtube.com/watch?v=dQw4w9WgXcQ',\n            quality: '1080p',\n            format: 'mp4',\n          })\n          .expect(201);\n\n        expect(response.body).toMatchObject({\n          videoId: 'dQw4w9WgXcQ',\n          title: 'Test Video',\n          status: 'queued',\n          progress: 0,\n          quality: '1080p',\n          format: 'mp4',\n        });\n      });\n\n      it('should enforce download rate limits', async () => {\n        jest.spyOn(YouTubeClient.prototype, 'getVideoInfo')\n          .mockResolvedValue(mockVideoInfo);\n\n        // Make 5 download requests (the limit)\n        const requests = Array.from({ length: 6 }, (_, i) => \n          request(app)\n            .post('/api/youtube/download')\n            .set('Authorization', `Bearer ${authToken}`)\n            .send({\n              url: `https://www.youtube.com/watch?v=${i}`,\n              quality: '720p',\n              format: 'mp4',\n            })\n        );\n\n        const responses = await Promise.all(requests);\n        \n        // First 5 should succeed (or some might fail for other reasons)\n        // 6th should definitely be rate limited\n        expect(responses[5].status).toBe(429);\n        expect(responses[5].body).toMatchObject({\n          error: 'YouTube download rate limit exceeded',\n          limit: 5,\n          window: '1 hour',\n        });\n      });\n\n      it('should prevent duplicate downloads', async () => {\n        jest.spyOn(YouTubeClient.prototype, 'getVideoInfo')\n          .mockResolvedValue(mockVideoInfo);\n\n        // First download\n        await request(app)\n          .post('/api/youtube/download')\n          .set('Authorization', `Bearer ${authToken}`)\n          .send({\n            url: 'https://www.youtube.com/watch?v=dQw4w9WgXcQ',\n            quality: '720p',\n            format: 'mp4',\n          })\n          .expect(201);\n\n        // Duplicate should fail\n        const response = await request(app)\n          .post('/api/youtube/download')\n          .set('Authorization', `Bearer ${authToken}`)\n          .send({\n            url: 'https://www.youtube.com/watch?v=dQw4w9WgXcQ',\n            quality: '1080p',\n            format: 'mp4',\n          })\n          .expect(409);\n\n        expect(response.body.error).toBe('Video already downloading or queued');\n      });\n    });\n\n    describe('GET /api/youtube/downloads', () => {\n      it('should fetch user download history with filtering', async () => {\n        const response = await request(app)\n          .get('/api/youtube/downloads?page=1&limit=10&status=completed')\n          .set('Authorization', `Bearer ${authToken}`)\n          .expect(200);\n\n        expect(response.body).toMatchObject({\n          downloads: expect.any(Array),\n          total: expect.any(Number),\n          page: 1,\n          limit: 10,\n        });\n      });\n\n      it('should validate pagination parameters', async () => {\n        await request(app)\n          .get('/api/youtube/downloads?page=0&limit=101')\n          .set('Authorization', `Bearer ${authToken}`)\n          .expect(400);\n      });\n    });\n  });\n\n  describe('Webhook Integration', () => {\n    describe('POST /api/webhooks/overseerr', () => {\n      it('should process valid Overseerr webhook', async () => {\n        const payload = {\n          notification_type: 'MEDIA_REQUEST',\n          event: 'media.requested',\n          request: {\n            id: 123,\n            requestedBy: { displayName: 'Test User' },\n          },\n          media: {\n            title: 'Test Movie',\n            mediaType: 'movie',\n            posterPath: '/test-poster.jpg',\n          },\n        };\n\n        // Mock signature verification\n        const mockVerify = jest.spyOn(webhookIntegrationService, 'handleWebhook')\n          .mockImplementation(async (req, res) => {\n            res.status(200).json({ success: true, processed: true });\n          });\n\n        const response = await request(app)\n          .post('/api/webhooks/overseerr')\n          .set('X-Signature', 'sha256=test-signature')\n          .send(payload)\n          .expect(200);\n\n        expect(response.body).toMatchObject({\n          success: true,\n          processed: true,\n        });\n\n        mockVerify.mockRestore();\n      });\n\n      it('should reject webhooks with invalid signatures', async () => {\n        const payload = { event: 'test' };\n\n        await request(app)\n          .post('/api/webhooks/overseerr')\n          .set('X-Signature', 'invalid-signature')\n          .send(payload)\n          .expect(401);\n      });\n\n      it('should enforce webhook rate limits', async () => {\n        const payload = { event: 'test' };\n        \n        // Make requests up to the rate limit\n        const requests = Array.from({ length: 102 }, () => \n          request(app)\n            .post('/api/webhooks/overseerr')\n            .send(payload)\n        );\n\n        const responses = await Promise.all(requests);\n        \n        // Some requests should be rate limited\n        expect(responses.some(r => r.status === 429)).toBe(true);\n      });\n    });\n\n    describe('POST /api/webhooks/github', () => {\n      it('should process GitHub push webhooks', async () => {\n        const payload = {\n          event: 'push',\n          ref: 'refs/heads/main',\n          repository: {\n            full_name: 'test/repo',\n          },\n          commits: [\n            { id: 'abc123', message: 'Test commit' },\n          ],\n        };\n\n        const mockVerify = jest.spyOn(webhookIntegrationService, 'handleWebhook')\n          .mockImplementation(async (req, res) => {\n            res.status(200).json({ success: true, processed: true });\n          });\n\n        await request(app)\n          .post('/api/webhooks/github')\n          .set('X-Hub-Signature-256', 'sha256=test-signature')\n          .send(payload)\n          .expect(200);\n\n        mockVerify.mockRestore();\n      });\n    });\n\n    describe('GET /api/webhooks/health', () => {\n      it('should return webhook service health status', async () => {\n        const response = await request(app)\n          .get('/api/webhooks/health')\n          .expect(200);\n\n        expect(response.body).toMatchObject({\n          status: 'healthy',\n          service: 'Webhook Integration Service',\n          features: {\n            signatureVerification: true,\n            retryMechanism: true,\n            rateLimiting: true,\n            realTimeNotifications: true,\n          },\n        });\n      });\n    });\n  });\n\n  describe('Circuit Breaker Patterns', () => {\n    it('should open circuit breaker after consecutive failures', async () => {\n      // Mock consistent failures\n      const mockError = new Error('Service unavailable');\n      jest.spyOn(PlexClient.prototype, 'testConnection')\n        .mockRejectedValue(mockError);\n\n      // Make multiple requests to trigger circuit breaker\n      for (let i = 0; i < 6; i++) {\n        await request(app)\n          .get('/api/plex/health')\n          .set('Authorization', `Bearer ${authToken}`)\n          .expect(503);\n      }\n\n      // Circuit should be open now\n      const response = await request(app)\n        .get('/api/plex/health')\n        .set('Authorization', `Bearer ${authToken}`)\n        .expect(503);\n\n      expect(response.body.error).toContain('temporarily unavailable');\n    });\n  });\n\n  describe('Error Handling', () => {\n    it('should handle network timeouts gracefully', async () => {\n      jest.spyOn(PlexClient.prototype, 'testConnection')\n        .mockRejectedValue(new Error('ETIMEDOUT'));\n\n      const response = await request(app)\n        .get('/api/plex/health')\n        .set('Authorization', `Bearer ${authToken}`)\n        .expect(503);\n\n      expect(response.body).toMatchObject({\n        status: 'unhealthy',\n        error: 'ETIMEDOUT',\n      });\n    });\n\n    it('should sanitize error messages in production', async () => {\n      const originalEnv = process.env.NODE_ENV;\n      process.env.NODE_ENV = 'production';\n\n      jest.spyOn(PlexClient.prototype, 'testConnection')\n        .mockRejectedValue(new Error('Internal database connection failed with password: secret123'));\n\n      const response = await request(app)\n        .get('/api/plex/health')\n        .set('Authorization', `Bearer ${authToken}`)\n        .expect(503);\n\n      // Should not contain sensitive information\n      expect(response.body.error).not.toContain('password');\n      expect(response.body.error).not.toContain('secret123');\n\n      process.env.NODE_ENV = originalEnv;\n    });\n  });\n});